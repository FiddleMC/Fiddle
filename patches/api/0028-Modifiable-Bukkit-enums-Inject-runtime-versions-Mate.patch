From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Wed, 12 Jul 2023 23:19:48 +0200
Subject: [PATCH] Modifiable Bukkit enums - Inject runtime versions - Material
 - Name and key conversion

License: Fiddle Public License Agreement 1.0 (included in license/FPL-1.0.txt)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/org/bukkit/Material.java b/src/main/java/org/bukkit/Material.java
index e7e47030109356d330d4e2db026620db68ef9548..e915aaa335bebca76f34f4f8474e4e32e8e7f340 100644
--- a/src/main/java/org/bukkit/Material.java
+++ b/src/main/java/org/bukkit/Material.java
@@ -4761,33 +4761,58 @@ public enum Material implements AbstractMaterial { // Paper // Fiddle - modifiab
     /**
      * Attempts to match the Material with the given name.
      * <p>
-     * This is a match lookup; names will be stripped of the "minecraft:"
-     * namespace, converted to uppercase, then stripped of special characters in
-     * an attempt to format it like the enum.
+     * <!-- // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
+     * This is a match lookup; the first match returned by the following checks (evaluated in order) will be returned:
+     * <ol>
+     *     <li>A Material with the {@linkplain #getKey() namespaced key} equal to the given string (for example <code>"minecraft:stone_bricks"</code> or <code>"masonry:tuff_bricks"</code>)</li>
+     *     <li>A Material with a path (part behind the : in a namespaced key) equal to the given string (for example <code>"stone_bricks"</code> or <code>"tuff_bricks"</code>)</li>
+     *     <li>A Material with an enum name equal to the given string (for example <code>"STONE_BRICKS"</code>)</li>
+     * </ol>
+     * All of the above checks are each performed multiple times, in the following order:
+     * <ol>
+     *     <li>An exact match</li>
+     *     <li>A match ignoring case</li>
+     *     <li>A match ignoring case and only checking letters, digits, <code>_</code> and <code>:</code></li>
+     *     <li>A match ignoring case and only checking letters, digits and <code>_</code></li>
+     *     <li>A match ignoring case and only checking letters and digits</li>
+     * </ol>
      *
-     * @param name Name of the material to get
+     * @param string String of the material to get
+     * <!-- // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
      * @return Material if found, or null
      */
     @Nullable
-    public static Material matchMaterial(@NotNull final String name) {
-        return (Material) AbstractMaterial.matchAbstractMaterial(name); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial // Fiddle - modifiable Bukkit enums - move implementations to corresponding interfaces - Material
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    public static Material matchMaterial(@NotNull final String string) {
+        return (Material) AbstractMaterial.matchAbstractMaterial(string); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial // Fiddle - modifiable Bukkit enums - move implementations to corresponding interfaces - Material
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     }
 
     /**
      * Attempts to match the Material with the given name.
-     * <p>
-     * This is a match lookup; names will be stripped of the "minecraft:"
-     * namespace, converted to uppercase, then stripped of special characters in
-     * an attempt to format it like the enum.
-     *
-     * @param name Name of the material to get
+     * <!-- // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
+     * Returns the same as {@link #matchMaterial(String)} if {@code legacyName} is false.
+     * If {@code legacyName} is true, the following steps are performed in order:
+     * <ol>
+     *     <li>If the string starts with case-sensitive <code>"minecraft:"</code>, it is removed.</li>
+     *     <li>The string is transformed to uppercase.</li>
+     *     <li>Every contiguous substring of whitespace characters (as given by regex <code>\s</code>) is replaced by a single underscore (<code>_</code>).</li>
+     *     <li>Every non-word character (as given by regex <code>\W</code>) is removed.</li>
+     *     <li>If the string does not start with {@link MaterialLegacyNameChecker#LEGACY_MATERIAL_PREFIX}, it is prepended.</li>
+     *     <li>A Material with exactly the string as its enum name, if present, is mapped to its non-legacy variant (with priority for matching blocks over items) and returned.</li>
+     * </ol>
+     * @param string String of the material to get
+     * <!-- // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
      * @param legacyName whether this is a legacy name (see
      * {@link #getMaterial(java.lang.String, boolean)}
      * @return Material if found, or null
+     * @see #matchMaterial(String) <!-- // Fiddle - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
      */
     @Nullable
-    public static Material matchMaterial(@NotNull final String name, boolean legacyName) {
-        return (Material) AbstractMaterial.matchAbstractMaterial(name, legacyName); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial // Fiddle - modifiable Bukkit enums - move implementations to corresponding interfaces - Material
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    public static Material matchMaterial(@NotNull final String string, boolean legacyName) {
+        return (Material) AbstractMaterial.matchAbstractMaterial(string, legacyName); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial // Fiddle - modifiable Bukkit enums - move implementations to corresponding interfaces - Material
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     }
 
     /**
diff --git a/src/main/java/org/fiddlemc/fiddle/material/AbstractMaterial.java b/src/main/java/org/fiddlemc/fiddle/material/AbstractMaterial.java
index 61b37fe2a8bd54e76130431c82df1cf8b1243da1..7fd344807067e9b660f9d585811784b5c0b3abc6 100644
--- a/src/main/java/org/fiddlemc/fiddle/material/AbstractMaterial.java
+++ b/src/main/java/org/fiddlemc/fiddle/material/AbstractMaterial.java
@@ -155,16 +155,20 @@ public interface AbstractMaterial extends Keyed, Translatable, net.kyori.adventu
      * @deprecated Do not use: for internal use only.
      */
     @Deprecated(forRemoval = true)
-    static AbstractMaterial matchAbstractMaterial(@NotNull final String name) {
-        return MaterialNameAndKeyConversion.matchMaterial(name); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    static AbstractMaterial matchAbstractMaterial(@NotNull final String string) {
+        return MaterialNameAndKeyConversion.matchMaterial(string); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     }
 
     /**
      * @deprecated Do not use: for internal use only.
      */
     @Deprecated(forRemoval = true)
-    static AbstractMaterial matchAbstractMaterial(@NotNull final String name, boolean legacyName) {
-        return MaterialNameAndKeyConversion.matchMaterial(name, legacyName); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    static AbstractMaterial matchAbstractMaterial(@NotNull final String string, boolean legacyName) {
+        return MaterialNameAndKeyConversion.matchMaterial(string, legacyName); // Fiddle - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     }
 
     default boolean isRecord() {
diff --git a/src/main/java/org/fiddlemc/fiddle/material/FiddleEnumNamePrefix.java b/src/main/java/org/fiddlemc/fiddle/material/FiddleEnumNamePrefix.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf4a0138cacacc2284a3a0775a1cb4f6ddeb622f
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/material/FiddleEnumNamePrefix.java
@@ -0,0 +1,18 @@
+// Fiddle - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+
+package org.fiddlemc.fiddle.material;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A utility class solely for holding the {@link #PREFIX} value.
+ */
+public final class FiddleEnumNamePrefix {
+
+    private FiddleEnumNamePrefix() {
+        throw new RuntimeException();
+    }
+
+    public static final @NotNull String PREFIX = "FIDDLE_";
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/material/MaterialNameAndKeyConversion.java b/src/main/java/org/fiddlemc/fiddle/material/MaterialNameAndKeyConversion.java
index 6a43a90bd4fc533cfc5a738c3b196d72711b171e..2146330ed09ebcd9489f35b239b15c65b4e0029a 100644
--- a/src/main/java/org/fiddlemc/fiddle/material/MaterialNameAndKeyConversion.java
+++ b/src/main/java/org/fiddlemc/fiddle/material/MaterialNameAndKeyConversion.java
@@ -10,6 +10,7 @@ import org.bukkit.NamespacedKey;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
@@ -26,12 +27,42 @@ public final class MaterialNameAndKeyConversion {
         throw new RuntimeException();
     }
 
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    private static @Nullable Map<String, NamespacedKey> fiddleEnumNamesToNamespacedKey = new HashMap<>(0);
+
+    public static void registerFiddleEnumNameToNamespacedKey(@NotNull String enumName, @NotNull String namespace, @NotNull String path) {
+        if (fiddleEnumNamesToNamespacedKey == null) {
+            throw new IllegalStateException("Cannot register Fiddle enum name to namespaced key after the key cache has been filled");
+        }
+        fiddleEnumNamesToNamespacedKey.put(enumName, new NamespacedKey(namespace, path));
+    }
+    // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+
     // Fiddle start - modifiable Bukkit enums - Material - remove hard-coded properties - key
     private static final CachedMaterialProperty<NamespacedKey> keyCache = new CachedMaterialProperty<>(
         NamespacedKey[]::new,
-        // Based on the original org.bukkit.Material constructor
-        material -> NamespacedKey.minecraft(material.name().toLowerCase(Locale.ROOT))
-    );
+        // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+        material -> {
+            if (fiddleEnumNamesToNamespacedKey != null) {
+                @Nullable NamespacedKey fromFiddleEnumName = fiddleEnumNamesToNamespacedKey.get(material.name());
+                if (fromFiddleEnumName != null) {
+                    return fromFiddleEnumName;
+                }
+            }
+            // Based on the original org.bukkit.Material constructor
+            return NamespacedKey.minecraft(material.name().toLowerCase(Locale.ROOT));
+        }
+    ) {
+
+        @Override
+        protected void initializeIfNecessary(boolean legacy) {
+            super.initializeIfNecessary(legacy);
+            // Clear the registered Fiddle enum names to namespaced keys
+            fiddleEnumNamesToNamespacedKey = null;
+        }
+
+    };
+    // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     // Fiddle end - modifiable Bukkit enums - Material - remove hard-coded properties - key
 
     // Fiddle start - modifiable Bukkit enums - Material - remove hard-coded properties - getMaterial
@@ -48,6 +79,121 @@ public final class MaterialNameAndKeyConversion {
     }
     // Fiddle end - modifiable Bukkit enums - Material - remove hard-coded properties - getMaterial
 
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    private static @Nullable Map<String, Material> cachedMaterialsByMatchableString = null;
+
+    private static @NotNull Map<String, Material> getCachedMaterialsByMatchableString() {
+        if (cachedMaterialsByMatchableString == null) {
+            cachedMaterialsByMatchableString = Maps.newHashMap();
+            for (int valueIndex = 0; valueIndex < numberOfMatchMaterialValues; valueIndex++) {
+                for (int normalizationIndex = 0; normalizationIndex < NormalizedMatchMaterialStrings.numberOfNormalizations; normalizationIndex++) {
+                    for (var material : CachedMaterialProperty.getCachedMaterialValues()) {
+                        var value = getMatchMaterialValue(material, valueIndex);
+                        if (value != null) {
+                            var normalizedValue = new NormalizedMatchMaterialStrings(value).getNormalized(normalizationIndex);
+                            cachedMaterialsByMatchableString.putIfAbsent(normalizedValue, material);
+                        }
+                    }
+                }
+            }
+        }
+        return cachedMaterialsByMatchableString;
+    }
+
+    private static final int numberOfMatchMaterialValues = 3;
+
+    private static @Nullable String getMatchMaterialValue(@NotNull Material material, int valueIndex) {
+        return switch (valueIndex) {
+            case 0 -> material.isLegacy() ? null : material.getKey().toString();
+            case 1 -> material.isLegacy() ? null : material.getKey().getKey();
+            case 2 -> material.name();
+            default -> throw new IllegalArgumentException("Invalid valueIndex: " + valueIndex);
+        };
+    }
+
+    private static class NormalizedMatchMaterialStrings {
+
+        public static final int numberOfNormalizations = 5;
+
+        public final @NotNull String original;
+        private @Nullable String lowerCase;
+        private @Nullable String lowerCaseLettersDigitsUnderscoresAndColons;
+        private @Nullable String lowerCaseLettersDigitsAndUnderscores;
+        private @Nullable String lowerCaseLettersAndDigits;
+
+        public NormalizedMatchMaterialStrings(@NotNull String original) {
+            this.original = original;
+        }
+
+        public @NotNull String getLowerCase() {
+            if (this.lowerCase == null) {
+                this.lowerCase = this.original.toLowerCase(Locale.ROOT);
+            }
+            return this.lowerCase;
+        }
+
+        public @NotNull String getLowerCaseLettersDigitsUnderscoresAndColons() {
+            if (this.lowerCaseLettersDigitsUnderscoresAndColons == null) {
+                char[] characters = this.getLowerCase().toCharArray();
+                int writeIndex = 0;
+                for (int readIndex = 0; readIndex < characters.length; readIndex++) {
+                    char character = characters[readIndex];
+                    if ((character >= 'a' && character <= 'z') || (character >= '0' && character <= '9') || character == '_' || character == ':') {
+                        characters[writeIndex] = character;
+                        writeIndex++;
+                    }
+                }
+                this.lowerCaseLettersDigitsUnderscoresAndColons = new String(characters, 0, writeIndex);
+            }
+            return this.lowerCaseLettersDigitsUnderscoresAndColons;
+        }
+
+        public @NotNull String getLowerCaseLettersDigitsAndUnderscores() {
+            if (this.lowerCaseLettersDigitsAndUnderscores == null) {
+                char[] characters = this.getLowerCaseLettersDigitsUnderscoresAndColons().toCharArray();
+                int writeIndex = 0;
+                for (int readIndex = 0; readIndex < characters.length; readIndex++) {
+                    char character = characters[readIndex];
+                    if ((character >= 'a' && character <= 'z') || (character >= '0' && character <= '9') || character == '_') {
+                        characters[writeIndex] = character;
+                        writeIndex++;
+                    }
+                }
+                this.lowerCaseLettersDigitsAndUnderscores = new String(characters, 0, writeIndex);
+            }
+            return this.lowerCaseLettersDigitsAndUnderscores;
+        }
+
+        public @NotNull String getLowerCaseLettersAndDigits() {
+            if (this.lowerCaseLettersAndDigits == null) {
+                char[] characters = this.getLowerCaseLettersDigitsAndUnderscores().toCharArray();
+                int writeIndex = 0;
+                for (int readIndex = 0; readIndex < characters.length; readIndex++) {
+                    char character = characters[readIndex];
+                    if ((character >= 'a' && character <= 'z') || (character >= '0' && character <= '9')) {
+                        characters[writeIndex] = character;
+                        writeIndex++;
+                    }
+                }
+                this.lowerCaseLettersAndDigits = new String(characters, 0, writeIndex);
+            }
+            return this.lowerCaseLettersAndDigits;
+        }
+
+        public @NotNull String getNormalized(int normalizationIndex) {
+            return switch (normalizationIndex) {
+                case 0 -> this.original;
+                case 1 -> this.getLowerCase();
+                case 2 -> this.getLowerCaseLettersDigitsUnderscoresAndColons();
+                case 3 -> this.getLowerCaseLettersDigitsAndUnderscores();
+                case 4 -> this.getLowerCaseLettersAndDigits();
+                default -> throw new IllegalArgumentException("Invalid normalizationIndex: " + normalizationIndex);
+            };
+        }
+
+    }
+    // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+
     // Fiddle start - modifiable Bukkit enums - Material - remove hard-coded properties - key
     /**
      * @throws IllegalArgumentException If the given {@code material} is {@linkplain Material#isLegacy() legacy}.
@@ -80,20 +226,35 @@ public final class MaterialNameAndKeyConversion {
 
     // Fiddle start - modifiable Bukkit enums - Material - remove hard-coded properties - matchMaterial
     /**
-     * @throws IllegalArgumentException If the given {@code name} is null.
+     * @throws IllegalArgumentException If the given {@code string} is null. <!-- // Fiddle - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
      */
-    public static @Nullable Material matchMaterial(@NotNull final String name) {
-        return matchMaterial(name, false);
+    // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+    public static @Nullable Material matchMaterial(@NotNull final String string) {
+        return matchMaterial(string, false);
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
     }
 
     /**
-     * @throws IllegalArgumentException If the given {@code name} is null.
+     * @throws IllegalArgumentException If the given {@code string} is null. <!-- // Fiddle - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion -->
      */
-    public static @Nullable Material matchMaterial(@NotNull final String name, boolean legacyName) {
+    public static @Nullable Material matchMaterial(@NotNull final String string, boolean legacyName) { // Fiddle - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
         // Based on the original org.bukkit.Material#matchMaterial(String, boolean)
-        Preconditions.checkArgument(name != null, "Name cannot be null");
+        // Fiddle start - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
+        Preconditions.checkArgument(string != null, "Name string given to matchMaterial(...) cannot be null");
+        if (!legacyName) {
+            var cachedMaterialsByMatchableString = getCachedMaterialsByMatchableString();
+            var normalizedStrings = new NormalizedMatchMaterialStrings(string);
+            for (int normalizationIndex = 0; normalizationIndex < NormalizedMatchMaterialStrings.numberOfNormalizations; normalizationIndex++) {
+                var materialFound = cachedMaterialsByMatchableString.get(normalizedStrings.getNormalized(normalizationIndex));
+                if (materialFound != null) {
+                    return materialFound;
+                }
+            }
+            return null;
+        }
 
-        String filtered = name;
+        String filtered = string;
+        // Fiddle end - modifiable Bukkit enums - inject runtime versions - Material - name and key conversion
         if (filtered.startsWith(NamespacedKey.MINECRAFT + ":")) {
             filtered = filtered.substring((NamespacedKey.MINECRAFT + ":").length());
         }
diff --git a/src/test/java/org/bukkit/MaterialTest.java b/src/test/java/org/bukkit/MaterialTest.java
index 6b0eaaadf9772a4850cb70cea2bfe72a81a47a04..ae3766e1804ca495ee1f5e1ee77cd1b4fee916b8 100644
--- a/src/test/java/org/bukkit/MaterialTest.java
+++ b/src/test/java/org/bukkit/MaterialTest.java
@@ -52,6 +52,18 @@ public class MaterialTest {
         }
     }
 
+    // Fiddle start - modifiable Bukkit enums - Material - remove hard-coded properties - key
+    @Test
+    public void matchMaterialByKeyPath() {
+        for (Material material : Material.values()) {
+            if (material.isLegacy()) {
+                continue;
+            }
+            assertThat(Material.matchMaterial(material.getKey().getKey()), is(material));
+        }
+    }
+    // Fiddle end - modifiable Bukkit enums - Material - remove hard-coded properties - key
+
     @Test
     public void matchMaterialByWrongNamespace() {
         for (Material material : Material.values()) {
