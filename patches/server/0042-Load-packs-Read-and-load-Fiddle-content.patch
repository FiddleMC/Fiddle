From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Fri, 14 Jul 2023 20:18:27 +0200
Subject: [PATCH] Load packs - Read and load Fiddle content

License: Fiddle Public License Agreement 1.0 (included in license/FPL-1.0.txt)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index b3c05060ae157841c001f007fb31b6842571b330..da6139bc1407de461600331aa521cc3c78a77d07 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -76,6 +76,7 @@ import org.bukkit.Material;
 import org.fiddlemc.fiddle.configuration.FiddleConfigurations;
 import org.fiddlemc.fiddle.configuration.PermanenceConfirmation;
 import org.fiddlemc.fiddle.material.*;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.fiddlemc.fiddle.pack.FiddlePacks;
@@ -217,6 +218,15 @@ public class Main {
             }
             // Fiddle end - read packs - prevent duplicate packs
 
+            // Fiddle start - load packs - blocks and items - read definitions
+            try {
+                PackFiddleDefinitionLoader.readAndPrepareDefinitions();
+            } catch (Exception e) {
+                LOGGER.error("Could not read block and item definitions", e);
+                return;
+            }
+            // Fiddle end - load packs - blocks and items - read definitions
+
             io.papermc.paper.plugin.PluginInitializerManager.load(optionset); // Paper
             Bootstrap.bootStrap();
             Bootstrap.validate();
@@ -458,6 +468,9 @@ public class Main {
                 return;
             }
 
+            // Fiddle start - load packs - blocks and items - clear read definitions
+            PackFiddleDefinitionLoader.clearCachedDefinitions();
+            // Fiddle end - load packs - blocks and items - clear read definitions
             StartupPackLoadPhase.endStartupLoadPhase(); // Fiddle - read packs - startup load phase - end after initial read
             // Fiddle start - read packs - close packs after initial read
             for (var pack : FiddlePacks.getPacks()) {
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index 5f20e075c532f0f1d413242949d1738c0c152bf7..443447a730584534145eb0dbbce264e4a9b3f7e8 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.item;
 
+import com.mojang.logging.LogUtils;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -16,8 +17,13 @@ import net.minecraft.world.item.armortrim.TrimPatterns;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
+import org.slf4j.Logger;
 
 public class Items {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger(); // Fiddle end - load packs - items - register
+
     public static final Item AIR = registerBlock(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
     public static final Item STONE = registerBlock(Blocks.STONE);
     public static final Item GRANITE = registerBlock(Blocks.GRANITE);
@@ -1311,4 +1317,14 @@ public class Items {
 
         return Registry.register(BuiltInRegistries.ITEM, key, item);
     }
+
+    // Fiddle start - load packs - items - register
+    static {
+        for (var definition : PackFiddleDefinitionLoader.itemDefinitions) {
+            LOGGER.info("Registering item '" + definition.untypedResourceLocation + "'");
+            definition.register();
+        }
+    }
+    // Fiddle end - load packs - items - register
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index f41e335be934d24080472be9d260f1be7c01614d..4418949ac3f8669c9169f7d7c0dbc16f4fdef98a 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.level.block;
 
 import java.util.function.ToIntFunction;
+
+import com.mojang.logging.LogUtils;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
@@ -8,6 +10,7 @@ import net.minecraft.core.cauldron.CauldronInteraction;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.data.worldgen.features.TreeFeatures;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.effect.MobEffects;
@@ -40,8 +43,13 @@ import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.material.MapColor;
 import net.minecraft.world.level.material.PushReaction;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
+import org.slf4j.Logger;
 
 public class Blocks {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger(); // Fiddle end - load packs - blocks - register
+
     public static final Block AIR = register("air", new AirBlock(BlockBehaviour.Properties.of().replaceable().noCollission().noLootTable().air()));
     public static final Block STONE = register("stone", new Block(BlockBehaviour.Properties.of().mapColor(MapColor.STONE).instrument(NoteBlockInstrument.BASEDRUM).requiresCorrectToolForDrops().strength(1.5F, 6.0F)));
     public static final Block GRANITE = register("granite", new Block(BlockBehaviour.Properties.of().mapColor(MapColor.DIRT).instrument(NoteBlockInstrument.BASEDRUM).requiresCorrectToolForDrops().strength(1.5F, 6.0F)));
@@ -1251,11 +1259,25 @@ public class Blocks {
         return Registry.register(BuiltInRegistries.BLOCK, id, block);
     }
 
+    // Fiddle start - load packs - blocks - load definitions
+    public static Block register(ResourceLocation id, Block block) {
+        return Registry.register(BuiltInRegistries.BLOCK, id, block);
+    }
+    // Fiddle end - load packs - blocks - load definitions
+
     public static void rebuildCache() {
         Block.BLOCK_STATE_REGISTRY.forEach(BlockBehaviour.BlockStateBase::initCache);
     }
 
     static {
+
+        // Fiddle start - load packs - blocks - register
+        for (var definition : PackFiddleDefinitionLoader.blockDefinitions) {
+            LOGGER.info("Registering block '" + definition.untypedResourceLocation + "'");
+            definition.register();
+        }
+        // Fiddle end - load packs - blocks - register
+
         for(Block block : BuiltInRegistries.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
                 Block.BLOCK_STATE_REGISTRY.add(blockState);
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..b0c9c63101d87db837fa3cd0f97f799fe8d2d10e
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java
@@ -0,0 +1,31 @@
+// Fiddle - load packs - blocks - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An abstract definition of a block to be added to Fiddle.
+ * Implementations of this class typically represent one or more block bases.
+ */
+public abstract class AbstractFiddleBlockDefinition extends FiddleContentDefinition {
+
+    protected AbstractFiddleBlockDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(ResourceDefinitionType.BLOCK, untypedResourceLocation);
+    }
+
+    protected abstract @NotNull Block buildBlock();
+
+    /**
+     * Registers a new {@link Block} to the block registry, corresponding to this definition.
+     *
+     * @return The registered block.
+     */
+    public @NotNull Block register() {
+        return Blocks.register(this.untypedResourceLocation, this.buildBlock());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c5005b8b965b96632d2d5c1d66df2bed57f692b
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java
@@ -0,0 +1,31 @@
+// Fiddle - load packs - items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An abstract definition of an item to be added to Fiddle.
+ * Implementations of this class typically represent one or more item bases.
+ */
+public abstract class AbstractFiddleItemDefinition extends FiddleContentDefinition {
+
+    protected AbstractFiddleItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(ResourceDefinitionType.ITEM, untypedResourceLocation);
+    }
+
+    protected abstract @NotNull Item buildItem();
+
+    /**
+     * Registers a new {@link Item} to the item registry, corresponding to this definition.
+     *
+     * @return The registered item.
+     */
+    public @NotNull Item register() {
+        return Items.registerItem(this.untypedResourceLocation.toString(), this.buildItem());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..94505c6711d387694000701fbb10804660f2743b
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java
@@ -0,0 +1,36 @@
+// Fiddle - load packs - blocks - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.properties.NoteBlockInstrument;
+import net.minecraft.world.level.material.MapColor;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An {@link AbstractFiddleBlockDefinition} of the most basic block base <code>minecraft:base/block</code>,
+ * corresponding to direct instances of {@link Block}.
+ */
+public class FiddleBlockDefinition extends AbstractFiddleBlockDefinition {
+
+    FiddleBlockDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    protected @NotNull BlockBehaviour.Properties buildProperties() {
+        return BlockBehaviour.Properties.of()
+            .mapColor(MapColor.STONE) // TODO make fields
+            .instrument(NoteBlockInstrument.BASEDRUM)
+            .requiresCorrectToolForDrops()
+            .strength(1.5F, 6.0F);
+    }
+
+    @Override
+    protected @NotNull Block buildBlock() {
+        return new Block(this.buildProperties());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..b216bff8572398373562d66819ded2e4aa490e41
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java
@@ -0,0 +1,45 @@
+// Fiddle - load packs - items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An {@link AbstractFiddleItemDefinition} of the item base <code>minecraft:base/item/block</code>,
+ * corresponding to direct instances of {@link BlockItem}.
+ */
+public class FiddleBlockItemDefinition extends FiddleItemDefinition {
+
+    FiddleBlockItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    @Override
+    public @NotNull List<@NotNull ResourceLocation> getReferencedResourceLocation(@NotNull ResourceDefinitionType type) {
+        var references = super.getReferencedResourceLocation(type);
+        if (type == ResourceDefinitionType.BLOCK) {
+            references = references instanceof ArrayList<?> ? references : new ArrayList<>(references);
+            references.add(this.untypedResourceLocation);
+        }
+        return references;
+    }
+
+    @Override
+    protected @NotNull BlockItem buildItem() {
+        return new BlockItem(BuiltInRegistries.BLOCK.get(this.untypedResourceLocation), this.buildProperties());
+    }
+
+    @Override
+    public @NotNull Item register() {
+        return Items.registerBlock(this.buildItem());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b036aade9ca5251f984f8f582928af78592121b
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java
@@ -0,0 +1,109 @@
+// Fiddle - load packs - blocks and items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.level.block.Block;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.stream.IntStream;
+
+/**
+ * A common base class for {@link FiddleBlockDefinition} and {@link FiddleItemDefinition}.
+ */
+public abstract class FiddleContentDefinition {
+
+    public final @NotNull ResourceDefinitionType type;
+
+    /**
+     * The untyped {@link ResourceLocation}, for example <code>minecraft:stone_bricks</code>.
+     */
+    public final @NotNull ResourceLocation untypedResourceLocation;
+
+    protected FiddleContentDefinition(@NotNull ResourceDefinitionType type, @NotNull ResourceLocation untypedResourceLocation) {
+        this.type = type;
+        this.untypedResourceLocation = untypedResourceLocation;
+    }
+
+    /**
+     * @return The typed {@link ResourceLocation}, for example <code>minecraft:block/stone_bricks</code>.
+     */
+    public final @NotNull ResourceLocation getTypedResourceLocation() {
+        return new ResourceLocation(this.untypedResourceLocation.getNamespace(), this.type.resourceLocationPathIdentifier + "/" + this.untypedResourceLocation.getPath());
+    }
+
+    /**
+     * @return A list of the untyped references in this definition,
+     * that require the referenced content to have been instantiated.
+     * For example, a {@link FiddleBlockItemDefinition} relies on its corresponding {@link FiddleBlockDefinition}
+     * to have been instantiated as a {@link Block} before being able to be instantiated as a {@link BlockItem}.
+     */
+    public @NotNull List<@NotNull ResourceLocation> getReferencedResourceLocation(@NotNull ResourceDefinitionType type) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.untypedResourceLocation.toString();
+    }
+
+    /**
+     * Gets a topologically sorted copy of the given {@code definitions}.
+     * <br>
+     * All definitions in the given list must have the same {@linkplain #type type}
+     * (this is not checked by the implementation of this method).
+     * There may not be duplicate elements in the given list
+     * (this is not checked by the implementation of this method).
+     *
+     * @return A new list, containing the same elements as the given list,
+     * but ordered topologically according to the dependency forest defined by the
+     * {@linkplain #getReferencedResourceLocation(ResourceDefinitionType) references} that definitions have to
+     * other definitions in the list.
+     *
+     * @throws IllegalArgumentException If there is a cyclic dependency in the given definitions.
+     */
+    public static <T extends FiddleContentDefinition> @NotNull List<@NotNull T> getSortedTopologicallyByReferences(@NotNull List<@NotNull T> definitions) {
+        if (definitions.isEmpty()) {
+            return Collections.emptyList();
+        }
+        Map<T, Integer> toIndexInDefinitions = new IdentityHashMap<>();
+        for (int i = 0; i < definitions.size(); i++) {
+            toIndexInDefinitions.put(definitions.get(i), i);
+        }
+        int[] dependenciesLeftToAdd = new int[definitions.size()];
+        List<List<T>> dependents = new ArrayList<>();
+        for (int i = 0; i < definitions.size(); i++) {
+            dependents.add(new ArrayList<>());
+        }
+        for (var definition : definitions) {
+            for (var dependency : definition.getReferencedResourceLocation(definition.type)) {
+                dependents.get(toIndexInDefinitions.get(dependency)).add(definition);
+            }
+        }
+        Queue<T> noUnaddedDependencies = new ArrayDeque<>(definitions.size());
+        for (int i = 0; i < definitions.size(); i++) {
+            if (dependenciesLeftToAdd[i] == 0) {
+                noUnaddedDependencies.add(definitions.get(i));
+            }
+        }
+        List<T> sorted = new ArrayList<>(definitions.size());
+        while (!noUnaddedDependencies.isEmpty()) {
+            var toAdd = noUnaddedDependencies.poll();
+            sorted.add(toAdd);
+            for (var dependent : dependents.get(toIndexInDefinitions.get(toAdd))) {
+                if (--dependenciesLeftToAdd[toIndexInDefinitions.get(dependent)] == 0) {
+                    noUnaddedDependencies.add(dependent);
+                }
+            }
+        }
+        if (sorted.size() == definitions.size()) {
+            return sorted;
+        }
+        // There was a cycle
+        // TODO backtrack to find it and report back the actual cycle
+        throw new IllegalArgumentException("There was a cyclic dependency in definitions of type '" + definitions.get(0).type.resourceLocationPathIdentifier + "'. The cycle is made up of some (but not all) of the following definitions: " + IntStream.range(0, definitions.size()).filter(index -> dependenciesLeftToAdd[index] > 0).mapToObj(definitions::get).map(definition -> definition.untypedResourceLocation.toString()).toList());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..51eff3075061874663ae58a58c9c472df0a30445
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java
@@ -0,0 +1,33 @@
+// Fiddle - load packs - items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.properties.NoteBlockInstrument;
+import net.minecraft.world.level.material.MapColor;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An {@link AbstractFiddleItemDefinition} of the most basic item base <code>minecraft:base/item</code>,
+ * corresponding to direct instances of {@link Item}.
+ */
+public class FiddleItemDefinition extends AbstractFiddleItemDefinition {
+
+    FiddleItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    protected @NotNull Item.Properties buildProperties() {
+        return new Item.Properties(); // TODO make properties fields
+    }
+
+    @Override
+    protected @NotNull Item buildItem() {
+        return new Item(this.buildProperties());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4a115b547c240d9737da8a6751b747baf46ce80
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java
@@ -0,0 +1,69 @@
+// Fiddle - load packs - blocks and items - load definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import com.mojang.logging.LogUtils;
+import org.fiddlemc.fiddle.pack.FiddlePacks;
+import org.fiddlemc.fiddle.pack.read.PackParseException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A utility class providing functionality to take {@linkplain PackFiddleDefinitionReader already read}
+ * definitions, prepare them to be loaded into the server and actually load them at the right moment.
+ */
+public final class PackFiddleDefinitionLoader {
+
+    private PackFiddleDefinitionLoader() {
+        throw new RuntimeException();
+    }
+
+    private static final @NotNull Logger LOGGER = LogUtils.getClassLogger();
+
+    /**
+     * Will be null until initialized, and null after processing has finished (to deallocate the memory).
+     */
+    public static @Nullable List<AbstractFiddleBlockDefinition> blockDefinitions;
+
+    /**
+     * Will be null until initialized, and null after processing has finished (to deallocate the memory).
+     */
+    public static @Nullable List<AbstractFiddleItemDefinition> itemDefinitions;
+
+    /**
+     * Reads the definitions from packs and performs any needed preparations
+     * (notably, storing them in memory so they can be used in the corresponding loading actions later).
+     */
+    public static void readAndPrepareDefinitions() throws PackParseException {
+        blockDefinitions = new ArrayList<>();
+        itemDefinitions = new ArrayList<>();
+        for (var pack : FiddlePacks.getPacks()) {
+            // Read block definitions
+            try {
+                blockDefinitions.addAll(PackFiddleDefinitionReader.readBlocks(pack));
+            } catch (Exception e) {
+                throw new PackParseException("Could not read blocks from a Fiddle pack '" + pack + "'", e);
+            }
+            // Read item definitions
+            try {
+                itemDefinitions.addAll(PackFiddleDefinitionReader.readItems(pack));
+            } catch (Exception e) {
+                throw new PackParseException("Could not read items from a Fiddle pack '" + pack + "'", e);
+            }
+        }
+        // Order the block definitions in usage
+        blockDefinitions = FiddleContentDefinition.getSortedTopologicallyByReferences(blockDefinitions);
+        // Order the item definitions in usage
+        itemDefinitions = FiddleContentDefinition.getSortedTopologicallyByReferences(itemDefinitions);
+    }
+
+    public static void clearCachedDefinitions() {
+        blockDefinitions = null;
+        itemDefinitions = null;
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..e881d633c3d6fcd6b81fc26234cf05daedf290c3
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java
@@ -0,0 +1,148 @@
+// Fiddle - load packs - blocks and items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.resources.ResourceLocation;
+import org.fiddlemc.fiddle.pack.FiddlePack;
+import org.fiddlemc.fiddle.pack.files.RegularFileInPack;
+import org.fiddlemc.fiddle.pack.read.ContentNamespacedKeyValidation;
+import org.fiddlemc.fiddle.pack.read.PackParseException;
+import org.fiddlemc.fiddle.pack.read.json.NamedJsonElement;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A utility class providing functionality to read definitions of blocks and items from a {@link FiddlePack}.
+ */
+public final class PackFiddleDefinitionReader {
+
+    private PackFiddleDefinitionReader() {
+        throw new RuntimeException();
+    }
+
+    private static final @NotNull String contentFolderName = "content";
+    private static final @NotNull String blocksFolderName = "blocks";
+    private static final @NotNull String itemsFolderName = "items";
+
+    private static final @NotNull Logger LOGGER = LogUtils.getClassLogger();
+
+    /**
+     * @return A (possibly empty) list of all regular files in the {@linkplain #contentFolderName Fiddle folder in packs},
+     * that have the following path:
+     * <code>&lt;pack root&gt;/&lt;{@link #contentFolderName}&gt;/&lt;a {@link ContentNamespacedKeyValidation#isValidNamespace valid namespace}&gt;/&lt;{@code subNamespaceFolderName}&gt;/&lt;a {@linkplain ContentNamespacedKeyValidation#isValidPathJSONFilename(String) valid namespaced key path}&gt;</the></the></the></code>,
+     * paired with their namespace.
+     */
+    private static @NotNull List<@NotNull Pair<@NotNull RegularFileInPack, @NotNull String>> getSubNamespacedFolderFilesInContentFolder(@NotNull FiddlePack pack, @NotNull String subNamespaceFolderName) throws PackParseException {
+        var contentFolder = pack.filesProvider().getTopLevelDirectory(contentFolderName);
+        if (contentFolder == null) {
+            return Collections.emptyList();
+        }
+        List<Pair<RegularFileInPack, String>> subNamespacedFolderFiles = new ArrayList<>(0);
+        for (var namespaceFolder : contentFolder.getTopLevelDirectories()) {
+            var namespace = namespaceFolder.getName();
+            if (!ContentNamespacedKeyValidation.isValidNamespace(namespace)) {
+                LOGGER.warn("Ignored invalid namespace folder in Fiddle pack: {} in {}", contentFolderName + "/" + namespace, pack.filesProvider().getLocation());
+                continue;
+            }
+            var subNamespaceFolder = namespaceFolder.getTopLevelDirectory(subNamespaceFolderName);
+            if (subNamespaceFolder == null) {
+                continue;
+            }
+            for (var subNamespaceFolderFile : subNamespaceFolder.getTopLevelRegularFiles()) {
+                var path = subNamespaceFolderFile.getName();
+                if (!ContentNamespacedKeyValidation.isValidPathJSONFilename(path)) {
+                    LOGGER.warn("Ignored invalid file name in Fiddle pack: {} in {}", contentFolderName + "/" + namespace + "/" + subNamespaceFolderName + "/" + path, pack.filesProvider().getLocation());
+                    continue;
+                }
+                subNamespacedFolderFiles.add(Pair.of(subNamespaceFolderFile, namespace));
+            }
+        }
+        return subNamespacedFolderFiles;
+    }
+
+    /**
+     * @return The same as {@link #getSubNamespacedFolderFilesInContentFolder}, but each pair of a file and
+     * namespace has been turned into the file opened and parsed as JSON, and the {@link ResourceLocation} made
+     * of the namespace and path.
+     */
+    private static @NotNull List<@NotNull Pair<@NotNull JsonElement, @NotNull ResourceLocation>> getSubNamespacedFolderFilesInContentFolderAsJSON(@NotNull FiddlePack pack, @NotNull String subNamespaceFolderName) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolder(pack, subNamespaceFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<Pair<JsonElement, ResourceLocation>> subNamespacedFolderFilesInContentFolderAsJSON = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var file = namespacedFolderFile.first();
+            var namespace = namespacedFolderFile.second();
+            var filename = file.getName();
+            var path = filename.substring(0, filename.length() - 5); // Remove .json
+            var resourceLocation = new ResourceLocation(namespace, path);
+            String fullFilePathInPack = contentFolderName + "/" + namespace + "/" + subNamespaceFolderName + "/" + path;
+            String fileContent;
+            try {
+                fileContent = file.getString(false);
+            } catch (Exception e) {
+                throw new PackParseException("An exception occurred while opening a file '" + fullFilePathInPack + "' in a pack '" + pack + "'.", e);
+            }
+            JsonElement json;
+            try {
+                json = JsonParser.parseString(fileContent);
+            } catch (Exception e) {
+                throw new PackParseException("An exception occurred while parsing '" + fullFilePathInPack + "' in a pack '" + pack + "' as JSON.", e);
+            }
+            subNamespacedFolderFilesInContentFolderAsJSON.add(Pair.of(json, resourceLocation));
+        }
+        return subNamespacedFolderFilesInContentFolderAsJSON;
+    }
+
+    public static @NotNull List<@NotNull AbstractFiddleBlockDefinition> readBlocks(@NotNull FiddlePack pack) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolderAsJSON(pack, blocksFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<AbstractFiddleBlockDefinition> blocks = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var json = namespacedFolderFile.first();
+            var resourceLocation = namespacedFolderFile.second();
+            try {
+                var blockJson = NamedJsonElement.get(json).getAsJsonObject();
+                // TODO read the parent
+                blocks.add(new FiddleBlockDefinition(resourceLocation));
+                // TODO read the collision box per block state (and provide a way to make it the same as the shape of that block state in assets/.../blockstates - although
+                // TODO same as above but the hit box
+            } catch (Exception e) {
+                throw new PackParseException("Could not parse block definition '" + resourceLocation + "' in pack '" + pack + "'", e);
+            }
+        }
+        return blocks;
+    }
+
+    public static @NotNull List<@NotNull AbstractFiddleItemDefinition> readItems(@NotNull FiddlePack pack) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolderAsJSON(pack, itemsFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<AbstractFiddleItemDefinition> items = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var json = namespacedFolderFile.first();
+            var resourceLocation = namespacedFolderFile.second();
+            try {
+                var itemJson = NamedJsonElement.get(json).getAsJsonObject();
+                // TODO read the parent
+                items.add(new FiddleBlockItemDefinition(resourceLocation));
+            } catch (Exception e) {
+                throw new PackParseException("Could not parse item definition '" + resourceLocation + "' in pack '" + pack + "'", e);
+            }
+        }
+        return items;
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..b31e19981753e10ac1ffbd6b84630f0b68d48ccc
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java
@@ -0,0 +1,29 @@
+// Fiddle - load packs - blocks and items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The type of content of a {@link ResourceDefinitionType}.
+ * This enum may also include content definition types that are not part of Fiddle,
+ * such as block models, crafting recipes or advancements.
+ */
+public enum ResourceDefinitionType {
+
+    /**
+     * The type of {@link FiddleBlockDefinition}s.
+     */
+    BLOCK("block"),
+    /**
+     * The type of {@link FiddleItemDefinition}s.
+     */
+    ITEM("item");
+
+    public final @NotNull String resourceLocationPathIdentifier;
+
+    ResourceDefinitionType(@NotNull String resourceLocationPathIdentifier) {
+        this.resourceLocationPathIdentifier = resourceLocationPathIdentifier;
+    }
+
+}
