From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Sat, 29 Jul 2023 13:28:41 +0200
Subject: [PATCH] Client perspective - Deep replacements - Necessary
 replacement hooks

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/nbt/CompoundTag.java b/src/main/java/net/minecraft/nbt/CompoundTag.java
index e9aeb22ed30261514ee92d429b76b4aa9892c461..d8f17e1779e7dfe4b373f84d07dbe6b669fc61c7 100644
--- a/src/main/java/net/minecraft/nbt/CompoundTag.java
+++ b/src/main/java/net/minecraft/nbt/CompoundTag.java
@@ -182,6 +182,12 @@ public class CompoundTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in CompoundTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         for(String string : this.tags.keySet()) {
             Tag tag = this.tags.get(string);
diff --git a/src/main/java/net/minecraft/nbt/ListTag.java b/src/main/java/net/minecraft/nbt/ListTag.java
index d70b0257ed990444a531e65cb275bbacc50b96b1..22de2910669807024a30bf8a935de829ea5fc4a2 100644
--- a/src/main/java/net/minecraft/nbt/ListTag.java
+++ b/src/main/java/net/minecraft/nbt/ListTag.java
@@ -162,6 +162,13 @@ public class ListTag extends CollectionTag<Tag> {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         if (this.list.isEmpty()) {
             this.type = 0;
diff --git a/src/main/java/net/minecraft/nbt/StringTag.java b/src/main/java/net/minecraft/nbt/StringTag.java
index 0ad7ffe53b26136bd0aada84db3fe6662162c305..f8828df70a993323c12617f97224f074789ec8de 100644
--- a/src/main/java/net/minecraft/nbt/StringTag.java
+++ b/src/main/java/net/minecraft/nbt/StringTag.java
@@ -73,6 +73,13 @@ public class StringTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         output.writeUTF(this.data);
     }
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 715aa4ae6e1e1ccdac7ae55e6946973f8bb2b4ad..354c6635b183ff77364bd09aa768c65dae658d2a 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -601,6 +601,12 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeComponent(Component text, org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            return this.writeComponent(org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceComponent(text, clientPerspectiveAndSettings, replacementScope), clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
         // Fiddle end - client perspective - deep replacements - pass scope
         if (text instanceof io.papermc.paper.adventure.AdventureComponent adv) {
             return this.writeComponent(adv.adventure$component());
@@ -748,6 +754,12 @@ public class FriendlyByteBuf extends ByteBuf {
         if (stack.isEmpty() || stack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeBoolean(false);
         } else {
+            // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
+            replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+            if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+                return this.writeItem(org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceItemStack(stack, itemStackInPackContext, clientPerspectiveAndSettings, replacementScope), itemStackInPackContext, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            }
+            // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
             this.writeBoolean(true);
             Item item = stack.getItem();
 
diff --git a/src/main/java/net/minecraft/network/Utf8String.java b/src/main/java/net/minecraft/network/Utf8String.java
index 2c001d99a207cab3a7c4fdbed533ad8e4e2fb819..88cf9fe24c4c7d17260812f1ac6b730a5fa07a3d 100644
--- a/src/main/java/net/minecraft/network/Utf8String.java
+++ b/src/main/java/net/minecraft/network/Utf8String.java
@@ -30,7 +30,28 @@ public class Utf8String {
         }
     }
 
-    public static void write(ByteBuf buf, CharSequence string, int length, boolean canBeRawJsonText, boolean canBeSNBT, org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+    // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
+    public static void write(ByteBuf buf, String string, int length, boolean canBeRawJsonText, boolean canBeSNBT, org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            String modifiedString;
+            if (canBeRawJsonText) {
+                if (canBeSNBT) {
+                    modifiedString = org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceRawJSONTextOrSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceRawJSONText(string, clientPerspectiveAndSettings, replacementScope);
+                }
+            } else {
+                if (canBeSNBT) {
+                    modifiedString = org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = string;
+                }
+            }
+            write(buf, modifiedString, length, canBeRawJsonText, canBeSNBT, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
         if (string.length() > length) {
             throw new EncoderException("String too big (was " + string.length() + " characters, max " + length + ")");
         } else {
diff --git a/src/main/java/net/minecraft/network/chat/Component.java b/src/main/java/net/minecraft/network/chat/Component.java
index d3a80d0a23be762c05931ae8001d98e43cab2b4a..aa9eb198f3bb5223fec7bbf010d43666f5a59d90 100644
--- a/src/main/java/net/minecraft/network/chat/Component.java
+++ b/src/main/java/net/minecraft/network/chat/Component.java
@@ -101,6 +101,12 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
         return new MutableComponent(this.getContents(), new ArrayList(this.getSiblings()), this.getStyle());
     }
 
+    // Fiddle start - client perspective - deep replacements - hooks for replacements - copy component with new contents
+    default MutableComponent withContents(ComponentContents contents) {
+        return new MutableComponent(contents, this.getSiblings(), this.getStyle());
+    }
+    // Fiddle end - client perspective - deep replacements - hooks for replacements - copy component with new contents
+
     FormattedCharSequence getVisualOrderText();
 
     @Override
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
new file mode 100644
index 0000000000000000000000000000000000000000..2d90d8d2dac7bedbf472f3a5af8493621b003c9b
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
@@ -0,0 +1,432 @@
+// Fiddle - client perspective - deep replacements - hooks for replacements
+
+package org.fiddlemc.fiddle.packet.deepreplacement;
+
+import com.mojang.brigadier.StringReader;
+import net.minecraft.nbt.*;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentContents;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.world.item.ItemStack;
+import org.fiddlemc.fiddle.packet.item.ItemStackInPacketContext;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * A class providing static functionality for applying the possible deep replacements.
+ */
+@SuppressWarnings("StringEquality")
+public final class DeepReplacer {
+
+    private DeepReplacer() {
+        throw new RuntimeException();
+    }
+
+    /**
+     * Attempts to apply {@link #replaceRawJSONText} and {@link #replaceSNBT},
+     * in that order, and returns the first result that is different from the given value.
+     */
+    public static String replaceRawJSONTextOrSNBT(String value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+        var modifiedValue = replaceRawJSONText(value, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedValue != value) {
+            return modifiedValue;
+        }
+        return replaceSNBT(value, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is serialized raw JSON text.
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static String replaceRawJSONText(String value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+
+        // We only need to replace in hover events if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceInHoverEvents && !value.contains("\"hoverEvent")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceInHoverEvents();
+        }
+        // We never need to replace blocks in raw JSON text, and we only need to replace items if there are any present, which there can only be in raw JSON text for hover events of the show_item type
+        if (replacementScope.attemptToReplaceItemsAndBlocks && !(replacementScope.attemptToReplaceInHoverEvents && value.contains("show_item"))) {
+            replacementScope = replacementScope.withoutAttemptToReplaceItemsAndBlocks();
+        }
+        // We only need to replace translatables if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceTranslatables && !value.contains("\"translate")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceTranslatables();
+        }
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Deserialize the string and perform replacements on it
+        Component component;
+        try {
+            component = Component.Serializer.fromJson(value);
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+        if (component == null) {
+            // If the string represents null, no replacements need to be made
+            return value;
+        }
+        var modifiedComponent = replaceComponent(component, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedComponent == component) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return Component.Serializer.toJson(modifiedComponent);
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Component}.
+     * @return A {@link Component} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned component is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static Component replaceComponent(Component value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Keep track of the modified value, which remains null while no modifications have been made
+        MutableComponent modifiedValueOrNull = null;
+
+        // Modify the siblings (which is a bad name, they are children) if necessary
+        var siblings = value.getSiblings();
+        List<Component> modifiedSiblings = null;
+        for (int i = 0; i < siblings.size(); i++) {
+            var sibling = siblings.get(i);
+            // Make necessary replacements in the sibling
+            var modifiedSibling = replaceComponent(sibling, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedSibling == sibling) {
+                // If the sibling was unchanged, continue
+                continue;
+            }
+            // Instantiate the modified value
+            if (modifiedValueOrNull == null) {
+                modifiedValueOrNull = value.copy();
+                modifiedSiblings = modifiedValueOrNull.getSiblings();
+            }
+            // Replace the sibling with the modified sibling
+            modifiedSiblings.set(i, modifiedSibling);
+        }
+
+        // Modify the style (specifically, the hover event) if necessary
+        if (replacementScope.attemptToReplaceInHoverEvents) {
+            var style = value.getStyle();
+            var hoverEvent = style.getHoverEvent();
+            if (hoverEvent != null) {
+                var hoverAction = hoverEvent.getAction();
+
+                // Keep track of the modified hover event, which remains null while no modifications have been made
+                HoverEvent modifiedHoverEvent = null;
+
+                if (hoverAction == HoverEvent.Action.SHOW_TEXT) {
+                    // Replace the text, which is once again a component
+                    var showTextValue = hoverEvent.getValue(HoverEvent.Action.SHOW_TEXT);
+                    if (showTextValue != null) {
+                        // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                        var modifiedShowTextValue = replaceComponent(showTextValue, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                        if (modifiedShowTextValue != showTextValue) {
+                            modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, modifiedShowTextValue);
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ITEM) {
+                    // Replace the item
+                    if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                        var showItemValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ITEM);
+                        if (showItemValue != null) {
+                            try {
+                                var showItemItemStack = showItemValue.getItemStack();
+                                // Note that we never have to transitively replace in hover events
+                                var modifiedShowItemItemStack = replaceItemStack(showItemItemStack, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceInHoverEvents());
+                                if (modifiedShowItemItemStack != showItemItemStack) {
+                                    modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ITEM, new HoverEvent.ItemStackInfo(modifiedShowItemItemStack));
+                                }
+                            } catch (Exception ignored) {
+                                // If any exception occurs, we just leave the item stack as-is because we can not make replacements in malformed item stacks
+                            }
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ENTITY) {
+                    // Replace the entity, which is incomplete SNBT that only potentially requires replacements in the name
+                    var showEntityValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ENTITY);
+                    if (showEntityValue != null) {
+                        if (showEntityValue.name != null && showEntityValue.name.isPresent()) {
+                            var showEntityValueName = showEntityValue.name.get();
+                            // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                            var modifiedName = replaceComponent(showEntityValueName, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                            if (modifiedName != showEntityValueName) {
+                                modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new HoverEvent.EntityTooltipInfo(showEntityValue.type, showEntityValue.id, modifiedName));
+                            }
+                        }
+                    }
+                }
+                if (modifiedHoverEvent != null) {
+                    // Instantiate the modified value
+                    if (modifiedValueOrNull == null) {
+                        modifiedValueOrNull = value.copy();
+                    }
+                    // Replace the hover event with the modified hover event
+                    modifiedValueOrNull.setStyle(style.withHoverEvent(modifiedHoverEvent));
+                }
+            }
+        }
+
+        // Modify the contents if necessary (specifically, if they are translatable)
+        if (replacementScope.attemptToReplaceTranslatables) {
+            var contents = value.getContents();
+            if (contents instanceof TranslatableContents translatableContents) {
+
+                // Make replacements in the arguments
+                var arguments = translatableContents.getArgs();
+                // Keep track of the modified arguments array, which remains null while no modifications have been made
+                @Nullable Object[] modifiedArguments = null;
+                for (int argumentI = 0; argumentI < arguments.length; argumentI++) {
+                    var argument = arguments[argumentI];
+                    Object modifiedArgument;
+                    if (argument instanceof String argumentAsString) {
+                        modifiedArgument = replaceRawJSONText(argumentAsString, clientPerspectiveAndSettings, replacementScope);
+                    } else if (argument instanceof Component argumentAsComponent) {
+                        modifiedArgument = replaceComponent(argumentAsComponent, clientPerspectiveAndSettings, replacementScope);
+                    } else {
+                        modifiedArgument = argument;
+                    }
+                    if (modifiedArgument == argument) {
+                        // If the sibling was unchanged, continue
+                        continue;
+                    }
+                    // Instantiate the modified value
+                    if (modifiedArguments == null) {
+                        modifiedArguments = new Object[arguments.length];
+                        System.arraycopy(arguments, 0, modifiedArguments, 0, arguments.length);
+                    }
+                    // Replace the argument with the modified argument
+                    modifiedArguments[argumentI] = modifiedArgument;
+                }
+                // Instantiate the contents with modified arguments
+                var translatableContentsWithModifiedArguments = modifiedArguments != null ? new TranslatableContents(translatableContents.getKey(), translatableContents.getFallback(), modifiedArguments) : translatableContents;
+
+                // Attempt to apply translations on the server
+                var modifiedContents = replaceTranslatableContents(translatableContentsWithModifiedArguments, clientPerspectiveAndSettings.getLocale());
+                if (modifiedContents != contents) {
+                    // Replace the contents with the modified contents
+                    modifiedValueOrNull = (modifiedValueOrNull != null ? modifiedValueOrNull : value).withContents(modifiedContents);
+                }
+
+            }
+        }
+
+        // Return the modified component if modifications were made, or the original component otherwise
+        return modifiedValueOrNull != null ? modifiedValueOrNull : value;
+
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is stringified (serialized) NBT
+     * (also known as SNBT).
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static String replaceSNBT(String value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Attempt to deserialize the string
+        Tag tag;
+        try {
+            tag = new TagParser(new StringReader(value)).readValue();
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+
+        // If the result of deserialization is a StringTag with the exact string as value, there is no point in applying further replacements since it will just loop back here
+        if (tag instanceof StringTag stringTag && stringTag.getAsString().equals(value)) {
+            return value;
+        }
+
+        // Perform replacements on the tag
+        var modifiedTag = replaceTag(tag, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedTag == tag) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return modifiedTag.getAsString();
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Tag}.
+     * @return A {@link Tag} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned tag is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static Tag replaceTag(Tag value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        if (value.getId() == Tag.TAG_COMPOUND && value instanceof CompoundTag compoundValue) {
+
+            // Potentially, the tag represents an item: we simply assume this is possible only if it has the right keys
+            if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                var keys = compoundValue.getAllKeys();
+                if (compoundValue.contains("id", Tag.TAG_STRING) && compoundValue.contains("Count", Tag.TAG_BYTE)) {
+                    boolean hasOnlyValidKeys = true;
+                    forAllKeys:
+                    for (var key : keys) {
+                        switch (key) {
+                            case "id", "Count" -> {
+                            }
+                            case "tag" -> {
+                                if (!compoundValue.contains("tag", Tag.TAG_COMPOUND)) {
+                                    // The tag value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            case "Slot" -> {
+                                if (!compoundValue.contains("Slot", Tag.TAG_BYTE)) {
+                                    // The slot value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            default -> {
+                                // Any other keys are invalid
+                                hasOnlyValidKeys = false;
+                                break forAllKeys;
+                            }
+                        }
+                    }
+                    if (hasOnlyValidKeys) {
+
+                        try {
+                            var itemStack = ItemStack.of(compoundValue);
+                            var modifiedItemStack = replaceItemStack(itemStack, clientPerspectiveAndSettings, replacementScope);
+                            if (modifiedItemStack != itemStack) {
+                                // Copy the given value, but clear the id, count and tag in advance
+                                var modifiedValue = compoundValue.copy();
+                                modifiedValue.remove("id");
+                                modifiedValue.remove("Count");
+                                modifiedValue.remove("tag");
+                                // Save the modified item stack and return
+                                modifiedItemStack.save(modifiedValue);
+                                return modifiedValue;
+                            }
+                        } catch (Exception ignored) {
+                            // If it cannot be parsed, we skip replacements (no replacements can be made to malformed items)
+                        }
+
+                    }
+                }
+            }
+
+            // Otherwise, we make replacements in the individual subvalues
+            // Keep track of the modified arguments array, which remains null while no modifications have been made
+            @Nullable CompoundTag modifiedValue = null;
+            for (var key : compoundValue.getAllKeys()) {
+                var subvalue = compoundValue.get(key);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue == subvalue) {
+                    // If the subvalue was unchanged, continue
+                    continue;
+                }
+                // Instantiate the modified value
+                if (modifiedValue == null) {
+                    modifiedValue = new CompoundTag();
+                }
+                // Set the modified subvalue in the modified value
+                modifiedValue.put(key, modifiedSubvalue);
+            }
+            if (modifiedValue != null) {
+                // If a modified value was created, add any missing keys (that were tested before the first modified subvalue occurred)
+                for (var key : compoundValue.getAllKeys()) {
+                    if (!modifiedValue.contains(key)) {
+                        modifiedValue.put(key, compoundValue.get(key));
+                    }
+                }
+                // Return the modified value
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_LIST && value instanceof ListTag listValue) {
+
+            // <ake replacements in the individual subvalues
+            // Keep track of the modified value, which remains null while no modifications have been made
+            @Nullable ListTag modifiedValue = null;
+            for (int i = 0; i < listValue.size(); i++) {
+                var subvalue = listValue.get(i);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue != subvalue) {
+                    // Instantiate the modified value
+                    if (modifiedValue == null) {
+                        modifiedValue = new ListTag();
+                        for (int j = 0; j < i; j++) {
+                            modifiedValue.add(listValue.get(j));
+                        }
+                    }
+                    // Set the modified subvalue in the modified value
+                    modifiedValue.add(modifiedSubvalue);
+                } else if (modifiedValue != null) {
+                    // Add the original subvalue in the modified value
+                    modifiedValue.add(subvalue);
+                }
+            }
+            // Return the modified value if it was created
+            if (modifiedValue != null) {
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_STRING && value instanceof StringTag stringValue) {
+
+            // The string may be a serialized component or stringified NBT
+            var text = stringValue.getAsString();
+            var modifiedText = replaceRawJSONTextOrSNBT(text, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedText != text) {
+                return StringTag.valueOf(modifiedText);
+            }
+
+        }
+
+        // By default, if no other value was returned, we return the given instance
+        return value;
+
+    }
+
+    public static ItemStack replaceItemStack(ItemStack value, ItemStackInPacketContext itemStackInPacketContext, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+        // TODO call implementation
+        return value;
+    }
+
+    /**
+     * Nested {@link ItemStack}s always have the {@link ItemStackInPacketContext#DEFAULT} context.
+     */
+    private static ItemStack replaceItemStack(ItemStack value, ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, DeepReplacementScope replacementScope) {
+        return replaceItemStack(value, ItemStackInPacketContext.DEFAULT, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    private static ComponentContents replaceTranslatableContents(TranslatableContents value, @Nullable String locale) {
+        // TODO call implementation
+        return value;
+    }
+
+}
