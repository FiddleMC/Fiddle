From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Tue, 1 Aug 2023 20:52:37 +0200
Subject: [PATCH] Client perspective - Block visualization - Modify chunk
 packets

License: Fiddle Public License Agreement 1.0 (included in license/FPL-1.0.txt)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index 693120394265bb99251a55c9d299c3a6b6c4ed4b..278d9a9a1eb367042b52a12581c4f4f9736990c8 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -3,8 +3,12 @@ package net.minecraft.network.protocol.game;
 import com.google.common.collect.Lists;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.Semaphore;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 import net.minecraft.core.BlockPos;
@@ -18,7 +22,10 @@ import net.minecraft.world.level.block.entity.BlockEntityType;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.fiddlemc.fiddle.packet.block.ModifiedClientboundLevelChunkPacketDataBuffer;
 import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope;
+import org.jetbrains.annotations.NotNull;
 
 public class ClientboundLevelChunkPacketData {
     private static final int TWO_MEGABYTES = 2097152;
@@ -29,6 +36,17 @@ public class ClientboundLevelChunkPacketData {
     private final java.util.List<net.minecraft.network.protocol.Packet> extraPackets = new java.util.ArrayList<>();
     private static final int TE_LIMIT = Integer.getInteger("Paper.excessiveTELimit", 750);
 
+    // Fiddle start - client perspective - block visualization - modify chunk packets
+    /**
+     * A non-reentrant lock for starting and querying operations to compute the contents of the
+     * {@link ModifiedClientboundLevelChunkPacketDataBuffer}s thread-safely.
+     */
+    private final @NotNull Semaphore clientPerspectiveTaskLock = new Semaphore(1);
+
+    private boolean hasAntiXrayFinished = false;
+    private final @NotNull Map<ClientPerspective, ModifiedClientboundLevelChunkPacketDataBuffer> modifiedBuffers = new HashMap<>(1);
+    // Fiddle start - client perspective - block visualization - modify chunk packets
+
     public List<net.minecraft.network.protocol.Packet> getExtraPackets() {
         return this.extraPackets;
     }
@@ -88,15 +106,108 @@ public class ClientboundLevelChunkPacketData {
         }
     }
 
-    public void write(FriendlyByteBuf buf) {
+    public void writeForClientPerspective(FriendlyByteBuf buf, @Nullable ClientPerspective clientPerspective) { // Fiddle - client perspective - block visualization - modify chunk packets
         buf.writeNbt(this.heightmaps, DeepReplacementScope.NOTHING); // Fiddle - client perspective - deep replacements - pass scope - to FriendlyByteBuf#writeNbt - this never contains replaceables
-        buf.writeVarInt(this.buffer.length);
-        buf.writeBytes(this.buffer);
+        // Fiddle start - client perspective - block visualization - modify chunk packets
+        byte[] buffer;
+        int usedBufferLength;
+        if (clientPerspective == null) {
+            // Sending a chunk packet when the player has no client perspective should only occur at the time we send an air chunk packet to the player when they are joining
+            buffer = this.buffer;
+            usedBufferLength = this.buffer.length;
+        } else {
+            ModifiedClientboundLevelChunkPacketDataBuffer modifiedBuffer;
+            while (!this.clientPerspectiveTaskLock.tryAcquire()) {
+                Thread.onSpinWait();
+            }
+            try {
+                modifiedBuffer = this.modifiedBuffers.get(clientPerspective);
+            } finally {
+                this.clientPerspectiveTaskLock.release();
+            }
+            buffer = modifiedBuffer.getBuffer();
+            usedBufferLength = modifiedBuffer.getUsedLength();
+        }
+        buf.writeVarInt(usedBufferLength);
+        buf.writeBytes(buffer);
+        // Fiddle end - client perspective - block visualization - modify chunk packets
         buf.writeCollection(this.blockEntitiesData, (buf2, entry) -> {
             entry.write(buf2);
         });
     }
 
+    // Fiddle start - client perspective - block visualization - modify chunk packets
+    public boolean isReadyForClientPerspective(@Nullable ClientPerspective clientPerspective) {
+        // We are not ready if potential anti-x-ray has not finished yet
+        if (!this.hasAntiXrayFinished) {
+            return false;
+        }
+        // If the client has no perspective yet, we do not make any modifications, so we are ready
+        if (clientPerspective == null) {
+            return true;
+        }
+        // The data is ready for the client perspective if there is a modified buffer for the client perspective and its buffer value has been filled
+        @Nullable ModifiedClientboundLevelChunkPacketDataBuffer modifiedBuffer;
+        while (!this.clientPerspectiveTaskLock.tryAcquire()) {
+            Thread.onSpinWait();
+        }
+        try {
+            modifiedBuffer = this.modifiedBuffers.get(clientPerspective);
+        } finally {
+            this.clientPerspectiveTaskLock.release();
+        }
+        return modifiedBuffer != null && modifiedBuffer.getBuffer() != null;
+    }
+
+    public void onAntiXrayFinish() {
+        List<Map.Entry<ClientPerspective, ModifiedClientboundLevelChunkPacketDataBuffer>> entriesToStartTaskFor;
+        while (!this.clientPerspectiveTaskLock.tryAcquire()) {
+            Thread.onSpinWait();
+        }
+        try {
+            this.hasAntiXrayFinished = true;
+            entriesToStartTaskFor = new ArrayList<>(this.modifiedBuffers.entrySet());
+        } finally {
+            this.clientPerspectiveTaskLock.release();
+        }
+        for (var entry : entriesToStartTaskFor) {
+            this.startModifyBufferTask(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void willBeNeededForClientPerspective(@Nullable ClientPerspective clientPerspective) {
+        // We don't need to do anything special for players without a client perspective
+        if (clientPerspective == null) {
+            return;
+        }
+        while (!this.clientPerspectiveTaskLock.tryAcquire()) {
+            Thread.onSpinWait();
+        }
+        ModifiedClientboundLevelChunkPacketDataBuffer newModifiedBuffer;
+        try {
+            // We don't need to do anything if this client perspective was already needed
+            if (this.modifiedBuffers.containsKey(clientPerspective)) {
+                return;
+            }
+            // Create a modified buffer for the client perspective
+            newModifiedBuffer = new ModifiedClientboundLevelChunkPacketDataBuffer();
+            this.modifiedBuffers.put(clientPerspective, newModifiedBuffer);
+            if (!this.hasAntiXrayFinished) {
+                // We don't need to start a task for the client perspective if anti-x-ray hasn't finished yet
+                return;
+            }
+        } finally {
+            this.clientPerspectiveTaskLock.release();
+        }
+        this.startModifyBufferTask(clientPerspective, newModifiedBuffer);
+    }
+
+    private void startModifyBufferTask(@NotNull ClientPerspective clientPerspective, @NotNull ModifiedClientboundLevelChunkPacketDataBuffer modifiedBuffer) {
+        // Run the task inlined on the current thread
+        BlockStateReplacer.computeModifiedBufferForChunkData(this, clientPerspective, modifiedBuffer);
+    }
+    // Fiddle end - client perspective - block visualization - modify chunk packets
+
     private static int calculateChunkSize(LevelChunk chunk) {
         int i = 0;
 
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index a95d9b67f249140277297d70fb8db176e866bd14..cd9f79e173183ea97740cc17d4150165d2184904 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -2,27 +2,47 @@ package net.minecraft.network.protocol.game;
 
 import java.util.BitSet;
 import javax.annotation.Nullable;
+
+import net.minecraft.network.Connection;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.fiddlemc.fiddle.packet.block.ClientboundLevelChunkWithLightPacketForClient;
+import org.jetbrains.annotations.NotNull;
 
+// Fiddle start - client perspective - block visualization - modify chunk packets
+/**
+ * Instances of this class are only based on whether anti-x-ray applies to them or not.
+ * They must never actually be sent to a client.
+ * Instead, a derived {@link ClientboundLevelChunkWithLightPacketForClient} can be acquired using
+ * {@link #adaptForClient}.
+ * However, apart from calling {@link #adaptForClient} on a packet to get a modified packet to send to the client,
+ * {@link #willBeNeededForClientPerspective} must have been called before for the
+ * {@linkplain ClientPerspective perspective} of the client, to allow the necessary processing to be done.
+ */
+// Fiddle end - client perspective - block visualization - modify chunk packets
 public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePacketListener> {
     private final int x;
     private final int z;
     private final ClientboundLevelChunkPacketData chunkData;
     private final ClientboundLightUpdatePacketData lightData;
     // Paper start - Async-Anti-Xray - Ready flag for the connection
-    private volatile boolean ready;
 
     @Override
     public boolean isReady() {
-        return this.ready;
+        throw new UnsupportedOperationException(); // Fiddle - client perspective - block visualization - modify chunk packets - instances of this class cannot be sent to a client
     }
 
     public void setReady(boolean ready) {
-        this.ready = ready;
+        // Fiddle start - client perspective - block visualization - modify chunk packets
+        // This is called when anti-x-ray has finished processing (if necessary), so we can now start additional perspective-specific processing
+        if (ready) {
+            this.chunkData.onAntiXrayFinish();
+        }
+        // Fiddle end - client perspective - block visualization - modify chunk packets
     }
     // Paper end
 
@@ -48,12 +68,29 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
 
     @Override
     public void write(FriendlyByteBuf buf) {
+        // Fiddle start - client perspective - block visualization - modify chunk packets
+        // This packet can not be written directly
+        throw new UnsupportedOperationException();
+    }
+
+    public void writeForClientPerspective(FriendlyByteBuf buf, @Nullable ClientPerspective clientPerspective) {
+        // Fiddle end - client perspective - block visualization - modify chunk packets
         buf.writeInt(this.x);
         buf.writeInt(this.z);
-        this.chunkData.write(buf);
+        this.chunkData.writeForClientPerspective(buf, clientPerspective); // Fiddle - client perspective - block visualization - modify chunk packets
         this.lightData.write(buf);
     }
 
+    // Fiddle start - client perspective - block visualization - modify chunk packets
+    public boolean isReadyForClientPerspective(@Nullable ClientPerspective clientPerspective) {
+        return this.chunkData.isReadyForClientPerspective(clientPerspective);
+    }
+
+    public void willBeNeededForClientPerspective(@Nullable ClientPerspective clientPerspective) {
+        this.chunkData.willBeNeededForClientPerspective(clientPerspective);
+    }
+    // Fiddle end - client perspective - block visualization - modify chunk packets
+
     @Override
     public void handle(ClientGamePacketListener listener) {
         listener.handleLevelChunkWithLight(this);
@@ -67,10 +104,6 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.z;
     }
 
-    public ClientboundLevelChunkPacketData getChunkData() {
-        return this.chunkData;
-    }
-
     public ClientboundLightUpdatePacketData getLightData() {
         return this.lightData;
     }
@@ -81,4 +114,12 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
         return this.chunkData.getExtraPackets();
     }
     // Paper end
+
+    // Fiddle start - client perspective - block visualization - modify chunk packets
+    @Override
+    public @NotNull ClientboundLevelChunkWithLightPacketForClient adaptForClient(@NotNull Connection connection) {
+        return new ClientboundLevelChunkWithLightPacketForClient(this, connection);
+    }
+    // Fiddle end - client perspective - block visualization - modify chunk packets
+
 }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 9209b598d7168b82574e4800056b8b9f84265dd0..cbf9a41e8d1b856dfbcbe28fadafe582b46932f1 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1380,9 +1380,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-        player.trackChunk(chunk.getPos(), (Packet) cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
+        // Fiddle start - client perspective - block visualization - modify chunk packets
+        var chunkPacket = cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, (Boolean) s);
-        }));
+        });
+        chunkPacket.willBeNeededForClientPerspective(player.getClientPerspective());
+        player.trackChunk(chunk.getPos(), chunkPacket);
+        // Fiddle end - client perspective - block visualization - modify chunk packets
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
         // Paper - no longer needed - this was used to account for clients bugging out since they needed a chunk to store entities, but they no longer need a chunk
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 550dcb7d595221b221e4710890d8a3cad789fc07..d16853e748f8c187c525210df5ccee66c66b5ff1 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -520,9 +520,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                     if (player.connection == null) continue;
 
                     Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
+                    // Fiddle start - client perspective - block visualization - modify chunk packets
+                    var chunkPacket = refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
                         return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, (Boolean) s);
-                    }));
+                    });
+                    chunkPacket.willBeNeededForClientPerspective(player.getClientPerspective());
+                    player.connection.send(chunkPacket);
+                    // Fiddle end - client perspective - block visualization - modify chunk packets
                     // Paper end
                 }
         // Paper - rewrite player chunk loader
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/ClientboundLevelChunkWithLightPacketForClient.java b/src/main/java/org/fiddlemc/fiddle/packet/block/ClientboundLevelChunkWithLightPacketForClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..200ca1bd3e9db6e3270d8738f042b74b3b160db2
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/ClientboundLevelChunkWithLightPacketForClient.java
@@ -0,0 +1,46 @@
+// Fiddle - client perspective - block visualization - modify chunk packets
+
+package org.fiddlemc.fiddle.packet.block;
+
+import net.minecraft.network.Connection;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.game.ClientGamePacketListener;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.fiddlemc.fiddle.packet.PacketWithExplicitTargetClientConnection;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A packet reliant on an underlying {@link ClientboundLevelChunkWithLightPacket}, but for a specific client.
+ */
+public class ClientboundLevelChunkWithLightPacketForClient extends PacketWithExplicitTargetClientConnection<ClientGamePacketListener> {
+
+    private final @NotNull ClientboundLevelChunkWithLightPacket base;
+    private final @Nullable ClientPerspective clientPerspective;
+
+    public ClientboundLevelChunkWithLightPacketForClient(@NotNull ClientboundLevelChunkWithLightPacket base, @NotNull Connection connection) {
+        this.base = base;
+        this.clientPerspective = connection.getPlayerClientPerspective();
+        this.adaptForClient(connection);
+    }
+
+    @Override
+    public void write(@NotNull FriendlyByteBuf buf) {
+        // Instruct the base to write itself to the buffer, where the perspective-specific chunk data is used
+        this.base.writeForClientPerspective(buf, this.clientPerspective);
+    }
+
+    @Override
+    public boolean isReady() {
+        // This packet is ready if the computations for the client perspective have completed
+        return this.base.isReadyForClientPerspective(this.clientPerspective);
+    }
+
+    @Override
+    public void handle(@NotNull ClientGamePacketListener listener) {
+        // The server does not have to handle clientbound packets
+        throw new UnsupportedOperationException();
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/ModifiedClientboundLevelChunkPacketDataBuffer.java b/src/main/java/org/fiddlemc/fiddle/packet/block/ModifiedClientboundLevelChunkPacketDataBuffer.java
new file mode 100644
index 0000000000000000000000000000000000000000..33000285aac68f545ef777969a8270eb9bbfe043
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/ModifiedClientboundLevelChunkPacketDataBuffer.java
@@ -0,0 +1,34 @@
+// Fiddle - client perspective - block visualization - modify chunk packets
+
+package org.fiddlemc.fiddle.packet.block;
+
+import net.minecraft.network.protocol.game.ClientboundLevelChunkPacketData;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+
+/**
+ * A holder for a version of a {@link ClientboundLevelChunkPacketData}'s buffer that has been, or is yet to be,
+ * modified for a specific {@link ClientPerspective}.
+ */
+public final class ModifiedClientboundLevelChunkPacketDataBuffer {
+
+    /**
+     * Null while not {@linkplain #fill finished computing} yet.
+     */
+    private byte[] buffer;
+
+    private int usedLength;
+
+    public void fill(byte[] buffer, int usedLength) {
+        this.buffer = buffer;
+        this.usedLength = usedLength;
+    }
+
+    public byte[] getBuffer() {
+        return this.buffer;
+    }
+
+    public int getUsedLength() {
+        return this.usedLength;
+    }
+
+}
