From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Sat, 29 Jul 2023 13:28:41 +0200
Subject: [PATCH] Client perspective - Deep replacements - Necessary
 replacement hooks

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/nbt/CompoundTag.java b/src/main/java/net/minecraft/nbt/CompoundTag.java
index e1d968e0a9a2e0e4f42287b9639211a9a72eea42..1cf9d4bc6d94892b9739910f59f53f90c1ba6fcd 100644
--- a/src/main/java/net/minecraft/nbt/CompoundTag.java
+++ b/src/main/java/net/minecraft/nbt/CompoundTag.java
@@ -182,6 +182,13 @@ public class CompoundTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in CompoundTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in CompoundTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         for(String string : this.tags.keySet()) {
             Tag tag = this.tags.get(string);
diff --git a/src/main/java/net/minecraft/nbt/ListTag.java b/src/main/java/net/minecraft/nbt/ListTag.java
index b055c59629d7606a24b4be446e777013d6489721..3295729f82ae9759557a825437db8153b9c3746c 100644
--- a/src/main/java/net/minecraft/nbt/ListTag.java
+++ b/src/main/java/net/minecraft/nbt/ListTag.java
@@ -154,6 +154,13 @@ public class ListTag extends CollectionTag<Tag> {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         if (this.list.isEmpty()) {
             this.type = 0;
diff --git a/src/main/java/net/minecraft/nbt/StringTag.java b/src/main/java/net/minecraft/nbt/StringTag.java
index 3bfc92dbe12b0800a55e486818d8bf17c105cf92..5706937cef8f5b990f64bf769df35160417f9e86 100644
--- a/src/main/java/net/minecraft/nbt/StringTag.java
+++ b/src/main/java/net/minecraft/nbt/StringTag.java
@@ -73,6 +73,13 @@ public class StringTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         output.writeUTF(this.data);
     }
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 2155989f46d431ae0712da0b9255fda59b0c4317..f357a6a94a8fc67f4f51993cbcc4c830e55d44bf 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -80,6 +80,7 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 import org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier;
 import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope;
+import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer;
 import org.fiddlemc.fiddle.packet.item.ItemStackInPacketContext;
 import org.jetbrains.annotations.NotNull;
 import org.joml.Quaternionf;
@@ -618,6 +619,12 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeComponent(Component text, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != DeepReplacementScope.NOTHING) {
+            return this.writeComponent(DeepReplacer.replaceComponent(text, clientPerspectiveAndSettings, replacementScope), clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
         // Fiddle end - client perspective - deep replacements - pass scope
         // TODO this.adventure$locale
         return this.writeWithCodec(NbtOps.INSTANCE, ComponentSerialization.CODEC, text, clientPerspectiveAndSettings, replacementScope); // Fiddle - client perspective - deep replacements - pass scope
@@ -744,6 +751,12 @@ public class FriendlyByteBuf extends ByteBuf {
         if (stack.isEmpty() || stack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeBoolean(false);
         } else {
+            // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
+            replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+            if (replacementScope != DeepReplacementScope.NOTHING) {
+                return this.writeItem(DeepReplacer.replaceItemStack(stack, itemStackInPackContext, clientPerspectiveAndSettings, replacementScope), itemStackInPackContext, clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+            }
+            // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
             this.writeBoolean(true);
             Item item = stack.getItem();
 
@@ -819,6 +832,10 @@ public class FriendlyByteBuf extends ByteBuf {
         return this;
     }
 
+    private static int getMaxEncodedUtfLength(int decodedLength) {
+        return decodedLength * 3;
+    }
+
     public ResourceLocation readResourceLocation() {
         return new ResourceLocation(this.readUtf(32767));
     }
diff --git a/src/main/java/net/minecraft/network/Utf8String.java b/src/main/java/net/minecraft/network/Utf8String.java
index 3d5c67dc255684b60c2676f83fa4958a3ab5bf18..67a2a3897a8e00c8efa17e5e36942afa13b84e04 100644
--- a/src/main/java/net/minecraft/network/Utf8String.java
+++ b/src/main/java/net/minecraft/network/Utf8String.java
@@ -6,6 +6,7 @@ import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
 import org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier;
 import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope;
+import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer;
 import org.jetbrains.annotations.NotNull;
 
 import java.nio.charset.StandardCharsets;
@@ -34,7 +35,28 @@ public class Utf8String {
         }
     }
 
-    public static void write(ByteBuf buf, CharSequence string, int length, boolean canBeRawJsonText, boolean canBeSNBT, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+    public static void write(ByteBuf buf, String string, int length, boolean canBeRawJsonText, boolean canBeSNBT, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != DeepReplacementScope.NOTHING) {
+            String modifiedString;
+            if (canBeRawJsonText) {
+                if (canBeSNBT) {
+                    modifiedString = DeepReplacer.replaceRawJSONTextOrSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = DeepReplacer.replaceRawJSONText(string, clientPerspectiveAndSettings, replacementScope);
+                }
+            } else {
+                if (canBeSNBT) {
+                    modifiedString = DeepReplacer.replaceSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = string;
+                }
+            }
+            write(buf, modifiedString, length, canBeRawJsonText, canBeSNBT, clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
         if (string.length() > length) {
             throw new EncoderException("String too big (was " + string.length() + " characters, max " + length + ")");
         } else {
diff --git a/src/main/java/net/minecraft/network/chat/Component.java b/src/main/java/net/minecraft/network/chat/Component.java
index e0037b99838519eee5fb6f7e95ffaad252f08baf..a9f72e7f8b529345f07225783a6fbb541a993a96 100644
--- a/src/main/java/net/minecraft/network/chat/Component.java
+++ b/src/main/java/net/minecraft/network/chat/Component.java
@@ -102,6 +102,12 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
         return new MutableComponent(this.getContents(), new ArrayList(this.getSiblings()), this.getStyle());
     }
 
+    // Fiddle start - client perspective - deep replacements - hooks for replacements - copy component with new contents
+    default MutableComponent withContents(ComponentContents contents) {
+        return new MutableComponent(contents, this.getSiblings(), this.getStyle());
+    }
+    // Fiddle end - client perspective - deep replacements - hooks for replacements - copy component with new contents
+
     FormattedCharSequence getVisualOrderText();
 
     @Override
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c558ce8183e54dd10da8a86849944b49db14769e
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
@@ -0,0 +1,433 @@
+// Fiddle - client perspective - deep replacements - hooks for replacements
+
+package org.fiddlemc.fiddle.packet.deepreplacement;
+
+import com.mojang.brigadier.StringReader;
+import net.minecraft.nbt.*;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentContents;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.world.item.ItemStack;
+import org.fiddlemc.fiddle.packet.item.ItemStackInPacketContext;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * A class providing static functionality for applying the possible deep replacements.
+ */
+@SuppressWarnings("StringEquality")
+public final class DeepReplacer {
+
+    private DeepReplacer() {
+        throw new RuntimeException();
+    }
+
+    /**
+     * Attempts to apply {@link #replaceRawJSONText} and {@link #replaceSNBT},
+     * in that order, and returns the first result that is different from the given value.
+     */
+    public static @NotNull String replaceRawJSONTextOrSNBT(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        var modifiedValue = replaceRawJSONText(value, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedValue != value) {
+            return modifiedValue;
+        }
+        return replaceSNBT(value, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is serialized raw JSON text.
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull String replaceRawJSONText(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // We only need to replace in hover events if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceInHoverEvents && !value.contains("\"hoverEvent")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceInHoverEvents();
+        }
+        // We never need to replace blocks in raw JSON text, and we only need to replace items if there are any present, which there can only be in raw JSON text for hover events of the show_item type
+        if (replacementScope.attemptToReplaceItemsAndBlocks && !(replacementScope.attemptToReplaceInHoverEvents && value.contains("show_item"))) {
+            replacementScope = replacementScope.withoutAttemptToReplaceItemsAndBlocks();
+        }
+        // We only need to replace translatables if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceTranslatables && !value.contains("\"translate")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceTranslatables();
+        }
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Deserialize the string and perform replacements on it
+        Component component;
+        try {
+            component = Component.Serializer.fromJson(value);
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+        if (component == null) {
+            // If the string represents null, no replacements need to be made
+            return value;
+        }
+        var modifiedComponent = replaceComponent(component, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedComponent == component) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return Component.Serializer.toJson(modifiedComponent);
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Component}.
+     * @return A {@link Component} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned component is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull Component replaceComponent(@NotNull Component value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Keep track of the modified value, which remains null while no modifications have been made
+        MutableComponent modifiedValueOrNull = null;
+
+        // Modify the siblings (which is a bad name, they are children) if necessary
+        var siblings = value.getSiblings();
+        List<Component> modifiedSiblings = null;
+        for (int i = 0; i < siblings.size(); i++) {
+            var sibling = siblings.get(i);
+            // Make necessary replacements in the sibling
+            var modifiedSibling = replaceComponent(sibling, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedSibling == sibling) {
+                // If the sibling was unchanged, continue
+                continue;
+            }
+            // Instantiate the modified value
+            if (modifiedValueOrNull == null) {
+                modifiedValueOrNull = value.copy();
+                modifiedSiblings = modifiedValueOrNull.getSiblings();
+            }
+            // Replace the sibling with the modified sibling
+            modifiedSiblings.set(i, modifiedSibling);
+        }
+
+        // Modify the style (specifically, the hover event) if necessary
+        if (replacementScope.attemptToReplaceInHoverEvents) {
+            var style = value.getStyle();
+            var hoverEvent = style.getHoverEvent();
+            if (hoverEvent != null) {
+                var hoverAction = hoverEvent.getAction();
+
+                // Keep track of the modified hover event, which remains null while no modifications have been made
+                HoverEvent modifiedHoverEvent = null;
+
+                if (hoverAction == HoverEvent.Action.SHOW_TEXT) {
+                    // Replace the text, which is once again a component
+                    var showTextValue = hoverEvent.getValue(HoverEvent.Action.SHOW_TEXT);
+                    if (showTextValue != null) {
+                        // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                        var modifiedShowTextValue = replaceComponent(showTextValue, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                        if (modifiedShowTextValue != showTextValue) {
+                            modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, modifiedShowTextValue);
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ITEM) {
+                    // Replace the item
+                    if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                        var showItemValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ITEM);
+                        if (showItemValue != null) {
+                            try {
+                                var showItemItemStack = showItemValue.getItemStack();
+                                // Note that we never have to transitively replace in hover events
+                                var modifiedShowItemItemStack = replaceItemStack(showItemItemStack, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceInHoverEvents());
+                                if (modifiedShowItemItemStack != showItemItemStack) {
+                                    modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ITEM, new HoverEvent.ItemStackInfo(modifiedShowItemItemStack));
+                                }
+                            } catch (Exception ignored) {
+                                // If any exception occurs, we just leave the item stack as-is because we can not make replacements in malformed item stacks
+                            }
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ENTITY) {
+                    // Replace the entity, which is incomplete SNBT that only potentially requires replacements in the name
+                    var showEntityValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ENTITY);
+                    if (showEntityValue != null) {
+                        if (showEntityValue.name != null && showEntityValue.name.isPresent()) {
+                            var showEntityValueName = showEntityValue.name.get();
+                            // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                            var modifiedName = replaceComponent(showEntityValueName, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                            if (modifiedName != showEntityValueName) {
+                                modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new HoverEvent.EntityTooltipInfo(showEntityValue.type, showEntityValue.id, modifiedName));
+                            }
+                        }
+                    }
+                }
+                if (modifiedHoverEvent != null) {
+                    // Instantiate the modified value
+                    if (modifiedValueOrNull == null) {
+                        modifiedValueOrNull = value.copy();
+                    }
+                    // Replace the hover event with the modified hover event
+                    modifiedValueOrNull.setStyle(style.withHoverEvent(modifiedHoverEvent));
+                }
+            }
+        }
+
+        // Modify the contents if necessary (specifically, if they are translatable)
+        if (replacementScope.attemptToReplaceTranslatables) {
+            var contents = value.getContents();
+            if (contents instanceof TranslatableContents translatableContents) {
+
+                // Make replacements in the arguments
+                var arguments = translatableContents.getArgs();
+                // Keep track of the modified arguments array, which remains null while no modifications have been made
+                @Nullable Object[] modifiedArguments = null;
+                for (int argumentI = 0; argumentI < arguments.length; argumentI++) {
+                    var argument = arguments[argumentI];
+                    Object modifiedArgument;
+                    if (argument instanceof String argumentAsString) {
+                        modifiedArgument = replaceRawJSONText(argumentAsString, clientPerspectiveAndSettings, replacementScope);
+                    } else if (argument instanceof Component argumentAsComponent) {
+                        modifiedArgument = replaceComponent(argumentAsComponent, clientPerspectiveAndSettings, replacementScope);
+                    } else {
+                        modifiedArgument = argument;
+                    }
+                    if (modifiedArgument == argument) {
+                        // If the sibling was unchanged, continue
+                        continue;
+                    }
+                    // Instantiate the modified value
+                    if (modifiedArguments == null) {
+                        modifiedArguments = new Object[arguments.length];
+                        System.arraycopy(arguments, 0, modifiedArguments, 0, arguments.length);
+                    }
+                    // Replace the argument with the modified argument
+                    modifiedArguments[argumentI] = modifiedArgument;
+                }
+                // Instantiate the contents with modified arguments
+                var translatableContentsWithModifiedArguments = modifiedArguments != null ? new TranslatableContents(translatableContents.getKey(), translatableContents.getFallback(), modifiedArguments) : translatableContents;
+
+                // Attempt to apply translations on the server
+                var modifiedContents = replaceTranslatableContents(translatableContentsWithModifiedArguments, clientPerspectiveAndSettings.getLocale());
+                if (modifiedContents != contents) {
+                    // Replace the contents with the modified contents
+                    modifiedValueOrNull = (modifiedValueOrNull != null ? modifiedValueOrNull : value).withContents(modifiedContents);
+                }
+
+            }
+        }
+
+        // Return the modified component if modifications were made, or the original component otherwise
+        return modifiedValueOrNull != null ? modifiedValueOrNull : value;
+
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is stringified (serialized) NBT
+     * (also known as SNBT).
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull String replaceSNBT(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Attempt to deserialize the string
+        Tag tag;
+        try {
+            tag = new TagParser(new StringReader(value)).readValue();
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+
+        // If the result of deserialization is a StringTag with the exact string as value, there is no point in applying further replacements since it will just loop back here
+        if (tag instanceof StringTag stringTag && stringTag.getAsString().equals(value)) {
+            return value;
+        }
+
+        // Perform replacements on the tag
+        var modifiedTag = replaceTag(tag, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedTag == tag) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return modifiedTag.getAsString();
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Tag}.
+     * @return A {@link Tag} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned tag is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull Tag replaceTag(@NotNull Tag value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        if (value.getId() == Tag.TAG_COMPOUND && value instanceof CompoundTag compoundValue) {
+
+            // Potentially, the tag represents an item: we simply assume this is possible only if it has the right keys
+            if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                var keys = compoundValue.getAllKeys();
+                if (compoundValue.contains("id", Tag.TAG_STRING) && compoundValue.contains("Count", Tag.TAG_BYTE)) {
+                    boolean hasOnlyValidKeys = true;
+                    forAllKeys:
+                    for (var key : keys) {
+                        switch (key) {
+                            case "id", "Count" -> {
+                            }
+                            case "tag" -> {
+                                if (!compoundValue.contains("tag", Tag.TAG_COMPOUND)) {
+                                    // The tag value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            case "Slot" -> {
+                                if (!compoundValue.contains("Slot", Tag.TAG_BYTE)) {
+                                    // The slot value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            default -> {
+                                // Any other keys are invalid
+                                hasOnlyValidKeys = false;
+                                break forAllKeys;
+                            }
+                        }
+                    }
+                    if (hasOnlyValidKeys) {
+
+                        try {
+                            var itemStack = ItemStack.of(compoundValue);
+                            var modifiedItemStack = replaceItemStack(itemStack, clientPerspectiveAndSettings, replacementScope);
+                            if (modifiedItemStack != itemStack) {
+                                // Copy the given value, but clear the id, count and tag in advance
+                                var modifiedValue = compoundValue.copy();
+                                modifiedValue.remove("id");
+                                modifiedValue.remove("Count");
+                                modifiedValue.remove("tag");
+                                // Save the modified item stack and return
+                                modifiedItemStack.save(modifiedValue);
+                                return modifiedValue;
+                            }
+                        } catch (Exception ignored) {
+                            // If it cannot be parsed, we skip replacements (no replacements can be made to malformed items)
+                        }
+
+                    }
+                }
+            }
+
+            // Otherwise, we make replacements in the individual subvalues
+            // Keep track of the modified arguments array, which remains null while no modifications have been made
+            @Nullable CompoundTag modifiedValue = null;
+            for (var key : compoundValue.getAllKeys()) {
+                var subvalue = compoundValue.get(key);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue == subvalue) {
+                    // If the subvalue was unchanged, continue
+                    continue;
+                }
+                // Instantiate the modified value
+                if (modifiedValue == null) {
+                    modifiedValue = new CompoundTag();
+                }
+                // Set the modified subvalue in the modified value
+                modifiedValue.put(key, modifiedSubvalue);
+            }
+            if (modifiedValue != null) {
+                // If a modified value was created, add any missing keys (that were tested before the first modified subvalue occurred)
+                for (var key : compoundValue.getAllKeys()) {
+                    if (!modifiedValue.contains(key)) {
+                        modifiedValue.put(key, compoundValue.get(key));
+                    }
+                }
+                // Return the modified value
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_LIST && value instanceof ListTag listValue) {
+
+            // <ake replacements in the individual subvalues
+            // Keep track of the modified value, which remains null while no modifications have been made
+            @Nullable ListTag modifiedValue = null;
+            for (int i = 0; i < listValue.size(); i++) {
+                var subvalue = listValue.get(i);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue != subvalue) {
+                    // Instantiate the modified value
+                    if (modifiedValue == null) {
+                        modifiedValue = new ListTag();
+                        for (int j = 0; j < i; j++) {
+                            modifiedValue.add(listValue.get(j));
+                        }
+                    }
+                    // Set the modified subvalue in the modified value
+                    modifiedValue.add(modifiedSubvalue);
+                } else if (modifiedValue != null) {
+                    // Add the original subvalue in the modified value
+                    modifiedValue.add(subvalue);
+                }
+            }
+            // Return the modified value if it was created
+            if (modifiedValue != null) {
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_STRING && value instanceof StringTag stringValue) {
+
+            // The string may be a serialized component or stringified NBT
+            var text = stringValue.getAsString();
+            var modifiedText = replaceRawJSONTextOrSNBT(text, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedText != text) {
+                return StringTag.valueOf(modifiedText);
+            }
+
+        }
+
+        // By default, if no other value was returned, we return the given instance
+        return value;
+
+    }
+
+    public static @NotNull ItemStack replaceItemStack(@NotNull ItemStack value, @NotNull ItemStackInPacketContext itemStackInPacketContext, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        // TODO call implementation
+        return value;
+    }
+
+    /**
+     * Nested {@link ItemStack}s always have the {@link ItemStackInPacketContext#DEFAULT} context.
+     */
+    private static @NotNull ItemStack replaceItemStack(@NotNull ItemStack value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        return replaceItemStack(value, ItemStackInPacketContext.DEFAULT, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    private static @NotNull ComponentContents replaceTranslatableContents(@NotNull TranslatableContents value, @Nullable String locale) {
+        // TODO call implementation
+        return value;
+    }
+
+}
