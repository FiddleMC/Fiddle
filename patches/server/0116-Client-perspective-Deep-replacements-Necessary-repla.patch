From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Sat, 29 Jul 2023 13:28:41 +0200
Subject: [PATCH] Client perspective - Deep replacements - Necessary
 replacement hooks

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/nbt/CompoundTag.java b/src/main/java/net/minecraft/nbt/CompoundTag.java
index caa609116c5ae2175c99c3e1be4be4f080c21234..d4ae0bd5abbf4befc4b924c9f2112081463a2808 100644
--- a/src/main/java/net/minecraft/nbt/CompoundTag.java
+++ b/src/main/java/net/minecraft/nbt/CompoundTag.java
@@ -178,6 +178,13 @@ public class CompoundTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in CompoundTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in CompoundTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         for(String string : this.tags.keySet()) {
             Tag tag = this.tags.get(string);
diff --git a/src/main/java/net/minecraft/nbt/ListTag.java b/src/main/java/net/minecraft/nbt/ListTag.java
index 2130091f021844e145c7ee152806a68db0b464e1..7a61e2501eb200a6cff176f358c6a35642fc0f89 100644
--- a/src/main/java/net/minecraft/nbt/ListTag.java
+++ b/src/main/java/net/minecraft/nbt/ListTag.java
@@ -154,6 +154,13 @@ public class ListTag extends CollectionTag<Tag> {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in ListTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         if (this.list.isEmpty()) {
             this.type = 0;
diff --git a/src/main/java/net/minecraft/nbt/StringTag.java b/src/main/java/net/minecraft/nbt/StringTag.java
index c42bad629faab9fcf1ea971a7b4d6d3e77636279..d6090dc81ef05ae8d8e71a6f355ed6cb287b5707 100644
--- a/src/main/java/net/minecraft/nbt/StringTag.java
+++ b/src/main/java/net/minecraft/nbt/StringTag.java
@@ -75,6 +75,13 @@ public class StringTag implements Tag {
 
     @Override
     public void write(DataOutput output, @org.jetbrains.annotations.Nullable org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @org.jetbrains.annotations.NotNull org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope replacementScope) throws IOException {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING) {
+            org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer.replaceTag(this, clientPerspectiveAndSettings, replacementScope).write(output, clientPerspectiveAndSettings, org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in StringTag#write
         // Fiddle end - client perspective - deep replacements - pass scope
         try {
             output.writeUTF(this.data);
diff --git a/src/main/java/net/minecraft/network/FriendlyByteBuf.java b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
index 2c643b92d9f279a172cb49986a64a2db4f837f2c..b016b48607664f8abdc8bff45df3753d8141e501 100644
--- a/src/main/java/net/minecraft/network/FriendlyByteBuf.java
+++ b/src/main/java/net/minecraft/network/FriendlyByteBuf.java
@@ -79,6 +79,7 @@ import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
 import org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier;
 import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope;
+import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer;
 import org.fiddlemc.fiddle.packet.item.ItemStackInPacketContext;
 import org.jetbrains.annotations.NotNull;
 import org.joml.Quaternionf;
@@ -607,6 +608,12 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeComponent(Component text, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != DeepReplacementScope.NOTHING) {
+            return this.writeComponent(DeepReplacer.replaceComponent(text, clientPerspectiveAndSettings, replacementScope), clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeComponent
         // Fiddle end - client perspective - deep replacements - pass scope
         //return this.a(IChatBaseComponent.ChatSerializer.a(ichatbasecomponent), 262144); // Paper - comment
         return this.writeUtf(io.papermc.paper.adventure.PaperAdventure.asJsonString(text, this.adventure$locale), 262144, true, false, clientPerspectiveAndSettings, replacementScope); // Paper // Fiddle - client perspective - deep replacements - pass scope
@@ -733,6 +740,12 @@ public class FriendlyByteBuf extends ByteBuf {
         if (stack.isEmpty() || stack.getItem() == null) { // CraftBukkit - NPE fix itemstack.getItem()
             this.writeBoolean(false);
         } else {
+            // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
+            replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+            if (replacementScope != DeepReplacementScope.NOTHING) {
+                return this.writeItem(DeepReplacer.replaceItemStack(stack, itemStackInPackContext, clientPerspectiveAndSettings, replacementScope), itemStackInPackContext, clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+            }
+            // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in FriendlyByteBuf#writeItem
             this.writeBoolean(true);
             Item item = stack.getItem();
 
@@ -808,6 +821,10 @@ public class FriendlyByteBuf extends ByteBuf {
         return this;
     }
 
+    private static int getMaxEncodedUtfLength(int decodedLength) {
+        return decodedLength * 3;
+    }
+
     public ResourceLocation readResourceLocation() {
         return new ResourceLocation(this.readUtf(32767));
     }
diff --git a/src/main/java/net/minecraft/network/Utf8String.java b/src/main/java/net/minecraft/network/Utf8String.java
index 3d5c67dc255684b60c2676f83fa4958a3ab5bf18..67a2a3897a8e00c8efa17e5e36942afa13b84e04 100644
--- a/src/main/java/net/minecraft/network/Utf8String.java
+++ b/src/main/java/net/minecraft/network/Utf8String.java
@@ -6,6 +6,7 @@ import io.netty.handler.codec.DecoderException;
 import io.netty.handler.codec.EncoderException;
 import org.fiddlemc.fiddle.packet.deepreplacement.ClientPerspectiveAndSettingsSupplier;
 import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacementScope;
+import org.fiddlemc.fiddle.packet.deepreplacement.DeepReplacer;
 import org.jetbrains.annotations.NotNull;
 
 import java.nio.charset.StandardCharsets;
@@ -34,7 +35,28 @@ public class Utf8String {
         }
     }
 
-    public static void write(ByteBuf buf, CharSequence string, int length, boolean canBeRawJsonText, boolean canBeSNBT, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+    public static void write(ByteBuf buf, String string, int length, boolean canBeRawJsonText, boolean canBeSNBT, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) { // Fiddle - client perspective - deep replacements - pass scope
+        // Fiddle start - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
+        replacementScope = replacementScope.withoutUnnecessaryReplacements(clientPerspectiveAndSettings); // Remove unnecessary replacements
+        if (replacementScope != DeepReplacementScope.NOTHING) {
+            String modifiedString;
+            if (canBeRawJsonText) {
+                if (canBeSNBT) {
+                    modifiedString = DeepReplacer.replaceRawJSONTextOrSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = DeepReplacer.replaceRawJSONText(string, clientPerspectiveAndSettings, replacementScope);
+                }
+            } else {
+                if (canBeSNBT) {
+                    modifiedString = DeepReplacer.replaceSNBT(string, clientPerspectiveAndSettings, replacementScope);
+                } else {
+                    modifiedString = string;
+                }
+            }
+            write(buf, modifiedString, length, canBeRawJsonText, canBeSNBT, clientPerspectiveAndSettings, DeepReplacementScope.NOTHING);
+            return;
+        }
+        // Fiddle end - client perspective - deep replacements - hooks for replacements - insert hook in Utf8String#write
         if (string.length() > length) {
             throw new EncoderException("String too big (was " + string.length() + " characters, max " + length + ")");
         } else {
diff --git a/src/main/java/net/minecraft/network/chat/Component.java b/src/main/java/net/minecraft/network/chat/Component.java
index b540ce21c65ad52ad7e94d2ca2b3926c0875bee1..bd634f77039de1fcc3b4779cc19e60bc7ec30197 100644
--- a/src/main/java/net/minecraft/network/chat/Component.java
+++ b/src/main/java/net/minecraft/network/chat/Component.java
@@ -94,6 +94,12 @@ public interface Component extends Message, FormattedText, Iterable<Component> {
         return new MutableComponent(this.getContents(), new ArrayList(this.getSiblings()), this.getStyle());
     }
 
+    // Fiddle start - client perspective - deep replacements - hooks for replacements - copy component with new contents
+    default MutableComponent withContents(ComponentContents contents) {
+        return new MutableComponent(contents, this.getSiblings(), this.getStyle());
+    }
+    // Fiddle end - client perspective - deep replacements - hooks for replacements - copy component with new contents
+
     FormattedCharSequence getVisualOrderText();
 
     @Override
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
new file mode 100644
index 0000000000000000000000000000000000000000..176518b57b491e5a1bfafcfaa81af1fd1db16611
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/deepreplacement/DeepReplacer.java
@@ -0,0 +1,432 @@
+// Fiddle - client perspective - deep replacements - hooks for replacements
+
+package org.fiddlemc.fiddle.packet.deepreplacement;
+
+import com.mojang.brigadier.StringReader;
+import net.minecraft.nbt.*;
+import net.minecraft.network.chat.Component;
+import net.minecraft.network.chat.ComponentContents;
+import net.minecraft.network.chat.HoverEvent;
+import net.minecraft.network.chat.MutableComponent;
+import net.minecraft.network.chat.contents.TranslatableContents;
+import net.minecraft.world.item.ItemStack;
+import org.fiddlemc.fiddle.packet.item.ItemStackInPacketContext;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * A class providing static functionality for applying the possible deep replacements.
+ */
+@SuppressWarnings("StringEquality")
+public final class DeepReplacer {
+
+    private DeepReplacer() {
+        throw new RuntimeException();
+    }
+
+    /**
+     * Attempts to apply {@link #replaceRawJSONText} and {@link #replaceSNBT},
+     * in that order, and returns the first result that is different from the given value.
+     */
+    public static @NotNull String replaceRawJSONTextOrSNBT(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        var modifiedValue = replaceRawJSONText(value, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedValue != value) {
+            return modifiedValue;
+        }
+        return replaceSNBT(value, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is serialized raw JSON text.
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull String replaceRawJSONText(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // We only need to replace in hover events if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceInHoverEvents && !value.contains("\"hoverEvent")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceInHoverEvents();
+        }
+        // We never need to replace blocks in raw JSON text, and we only need to replace items if there are any present, which there can only be in raw JSON text for hover events of the show_item type
+        if (replacementScope.attemptToReplaceItemsAndBlocks && !(replacementScope.attemptToReplaceInHoverEvents && value.contains("show_item"))) {
+            replacementScope = replacementScope.withoutAttemptToReplaceItemsAndBlocks();
+        }
+        // We only need to replace translatables if there are any present, which there can only be if a specific substring is present
+        if (replacementScope.attemptToReplaceTranslatables && !value.contains("\"translate")) {
+            replacementScope = replacementScope.withoutAttemptToReplaceTranslatables();
+        }
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Deserialize the string and perform replacements on it
+        Component component;
+        try {
+            component = Component.Serializer.fromJson(value);
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+        if (component == null) {
+            // If the string represents null, no replacements need to be made
+            return value;
+        }
+        var modifiedComponent = replaceComponent(component, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedComponent == component) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return Component.Serializer.toJson(modifiedComponent);
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Component}.
+     * @return A {@link Component} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned component is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull Component replaceComponent(@NotNull Component value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Keep track of the modified value, which remains null while no modifications have been made
+        MutableComponent modifiedValueOrNull = null;
+
+        // Modify the siblings (which is a bad name, they are children) if necessary
+        var siblings = value.getSiblings();
+        List<Component> modifiedSiblings = null;
+        for (int i = 0; i < siblings.size(); i++) {
+            var sibling = siblings.get(i);
+            // Make necessary replacements in the sibling
+            var modifiedSibling = replaceComponent(sibling, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedSibling == sibling) {
+                // If the sibling was unchanged, continue
+                continue;
+            }
+            // Instantiate the modified value
+            if (modifiedValueOrNull == null) {
+                modifiedValueOrNull = value.copy();
+                modifiedSiblings = modifiedValueOrNull.getSiblings();
+            }
+            // Replace the sibling with the modified sibling
+            modifiedSiblings.set(i, modifiedSibling);
+        }
+
+        // Modify the style (specifically, the hover event) if necessary
+        if (replacementScope.attemptToReplaceInHoverEvents) {
+            var style = value.getStyle();
+            var hoverEvent = style.getHoverEvent();
+            if (hoverEvent != null) {
+                var hoverAction = hoverEvent.getAction();
+
+                // Keep track of the modified hover event, which remains null while no modifications have been made
+                HoverEvent modifiedHoverEvent = null;
+
+                if (hoverAction == HoverEvent.Action.SHOW_TEXT) {
+                    // Replace the text, which is once again a component
+                    var showTextValue = hoverEvent.getValue(HoverEvent.Action.SHOW_TEXT);
+                    if (showTextValue != null) {
+                        // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                        var modifiedShowTextValue = replaceComponent(showTextValue, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                        if (modifiedShowTextValue != showTextValue) {
+                            modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, modifiedShowTextValue);
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ITEM) {
+                    // Replace the item
+                    if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                        var showItemValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ITEM);
+                        if (showItemValue != null) {
+                            try {
+                                var showItemItemStack = showItemValue.getItemStack();
+                                // Note that we never have to transitively replace in hover events
+                                var modifiedShowItemItemStack = replaceItemStack(showItemItemStack, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceInHoverEvents());
+                                if (modifiedShowItemItemStack != showItemItemStack) {
+                                    modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ITEM, new HoverEvent.ItemStackInfo(modifiedShowItemItemStack));
+                                }
+                            } catch (Exception ignored) {
+                                // If any exception occurs, we just leave the item stack as-is because we can not make replacements in malformed item stacks
+                            }
+                        }
+                    }
+                } else if (hoverAction == HoverEvent.Action.SHOW_ENTITY) {
+                    // Replace the entity, which is incomplete SNBT that only potentially requires replacements in the name
+                    var showEntityValue = hoverEvent.getValue(HoverEvent.Action.SHOW_ENTITY);
+                    if (showEntityValue != null) {
+                        if (showEntityValue.name != null) {
+                            // Note that we never have to transitively replace in hover events, and thereby also do not have to replace any nested items or blocks
+                            var modifiedName = replaceComponent(showEntityValue.name, clientPerspectiveAndSettings, replacementScope.withoutAttemptToReplaceItemsAndBlocks().withoutAttemptToReplaceInHoverEvents());
+                            if (modifiedName != showEntityValue.name) {
+                                modifiedHoverEvent = new HoverEvent(HoverEvent.Action.SHOW_ENTITY, new HoverEvent.EntityTooltipInfo(showEntityValue.type, showEntityValue.id, modifiedName));
+                            }
+                        }
+                    }
+                }
+                if (modifiedHoverEvent != null) {
+                    // Instantiate the modified value
+                    if (modifiedValueOrNull == null) {
+                        modifiedValueOrNull = value.copy();
+                    }
+                    // Replace the hover event with the modified hover event
+                    modifiedValueOrNull.setStyle(style.withHoverEvent(modifiedHoverEvent));
+                }
+            }
+        }
+
+        // Modify the contents if necessary (specifically, if they are translatable)
+        if (replacementScope.attemptToReplaceTranslatables) {
+            var contents = value.getContents();
+            if (contents instanceof TranslatableContents translatableContents) {
+
+                // Make replacements in the arguments
+                var arguments = translatableContents.getArgs();
+                // Keep track of the modified arguments array, which remains null while no modifications have been made
+                @Nullable Object[] modifiedArguments = null;
+                for (int argumentI = 0; argumentI < arguments.length; argumentI++) {
+                    var argument = arguments[argumentI];
+                    Object modifiedArgument;
+                    if (argument instanceof String argumentAsString) {
+                        modifiedArgument = replaceRawJSONText(argumentAsString, clientPerspectiveAndSettings, replacementScope);
+                    } else if (argument instanceof Component argumentAsComponent) {
+                        modifiedArgument = replaceComponent(argumentAsComponent, clientPerspectiveAndSettings, replacementScope);
+                    } else {
+                        modifiedArgument = argument;
+                    }
+                    if (modifiedArgument == argument) {
+                        // If the sibling was unchanged, continue
+                        continue;
+                    }
+                    // Instantiate the modified value
+                    if (modifiedArguments == null) {
+                        modifiedArguments = new Object[arguments.length];
+                        System.arraycopy(arguments, 0, modifiedArguments, 0, arguments.length);
+                    }
+                    // Replace the argument with the modified argument
+                    modifiedArguments[argumentI] = modifiedArgument;
+                }
+                // Instantiate the contents with modified arguments
+                var translatableContentsWithModifiedArguments = modifiedArguments != null ? new TranslatableContents(translatableContents.getKey(), translatableContents.getFallback(), modifiedArguments) : translatableContents;
+
+                // Attempt to apply translations on the server
+                var modifiedContents = replaceTranslatableContents(translatableContentsWithModifiedArguments, clientPerspectiveAndSettings.getLocale());
+                if (modifiedContents != contents) {
+                    // Replace the contents with the modified contents
+                    modifiedValueOrNull = (modifiedValueOrNull != null ? modifiedValueOrNull : value).withContents(modifiedContents);
+                }
+
+            }
+        }
+
+        // Return the modified component if modifications were made, or the original component otherwise
+        return modifiedValueOrNull != null ? modifiedValueOrNull : value;
+
+    }
+
+    /**
+     * Replaces replaceables in a given string, when we know that this string is stringified (serialized) NBT
+     * (also known as SNBT).
+     * @return A string with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned string is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull String replaceSNBT(@NotNull String value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        // Attempt to deserialize the string
+        Tag tag;
+        try {
+            tag = new TagParser(new StringReader(value)).readValue();
+        } catch (Exception ignored) {
+            // If it cannot be deserialized, we skip replacements (no replacements can be made to malformed strings)
+            return value;
+        }
+
+        // If the result of deserialization is a StringTag with the exact string as value, there is no point in applying further replacements since it will just loop back here
+        if (tag instanceof StringTag stringTag && stringTag.getAsString().equals(value)) {
+            return value;
+        }
+
+        // Perform replacements on the tag
+        var modifiedTag = replaceTag(tag, clientPerspectiveAndSettings, replacementScope);
+        if (modifiedTag == tag) {
+            // If no changes were made, we return the given value instance
+            return value;
+        }
+        // Re-serialize and return
+        return modifiedTag.getAsString();
+
+    }
+
+    /**
+     * Replaces replaceables in a given {@link Tag}.
+     * @return A {@link Tag} with all needed replacements applied.
+     * When no replacements have been made (and as such, the returned tag is {@linkplain Object#equals equal}
+     * to the given {@code value}), this method will make a strong effort to return the given {@code value} instance.
+     */
+    public static @NotNull Tag replaceTag(@NotNull Tag value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+
+        // Skip if we have no replacements to make
+        if (!replacementScope.canMakeAnyReplacements()) {
+            return value;
+        }
+
+        if (value.getId() == Tag.TAG_COMPOUND && value instanceof CompoundTag compoundValue) {
+
+            // Potentially, the tag represents an item: we simply assume this is possible only if it has the right keys
+            if (replacementScope.attemptToReplaceItemsAndBlocks) {
+                var keys = compoundValue.getAllKeys();
+                if (compoundValue.contains("id", Tag.TAG_STRING) && compoundValue.contains("Count", Tag.TAG_BYTE)) {
+                    boolean hasOnlyValidKeys = true;
+                    forAllKeys:
+                    for (var key : keys) {
+                        switch (key) {
+                            case "id", "Count" -> {
+                            }
+                            case "tag" -> {
+                                if (!compoundValue.contains("tag", Tag.TAG_COMPOUND)) {
+                                    // The tag value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            case "Slot" -> {
+                                if (!compoundValue.contains("Slot", Tag.TAG_BYTE)) {
+                                    // The slot value is of the wrong type
+                                    hasOnlyValidKeys = false;
+                                    break forAllKeys;
+                                }
+                            }
+                            default -> {
+                                // Any other keys are invalid
+                                hasOnlyValidKeys = false;
+                                break forAllKeys;
+                            }
+                        }
+                    }
+                    if (hasOnlyValidKeys) {
+
+                        try {
+                            var itemStack = ItemStack.of(compoundValue);
+                            var modifiedItemStack = replaceItemStack(itemStack, clientPerspectiveAndSettings, replacementScope);
+                            if (modifiedItemStack != itemStack) {
+                                // Copy the given value, but clear the id, count and tag in advance
+                                var modifiedValue = compoundValue.copy();
+                                modifiedValue.remove("id");
+                                modifiedValue.remove("Count");
+                                modifiedValue.remove("tag");
+                                // Save the modified item stack and return
+                                modifiedItemStack.save(modifiedValue);
+                                return modifiedValue;
+                            }
+                        } catch (Exception ignored) {
+                            // If it cannot be parsed, we skip replacements (no replacements can be made to malformed items)
+                        }
+
+                    }
+                }
+            }
+
+            // Otherwise, we make replacements in the individual subvalues
+            // Keep track of the modified arguments array, which remains null while no modifications have been made
+            @Nullable CompoundTag modifiedValue = null;
+            for (var key : compoundValue.getAllKeys()) {
+                var subvalue = compoundValue.get(key);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue == subvalue) {
+                    // If the subvalue was unchanged, continue
+                    continue;
+                }
+                // Instantiate the modified value
+                if (modifiedValue == null) {
+                    modifiedValue = new CompoundTag();
+                }
+                // Set the modified subvalue in the modified value
+                modifiedValue.put(key, modifiedSubvalue);
+            }
+            if (modifiedValue != null) {
+                // If a modified value was created, add any missing keys (that were tested before the first modified subvalue occurred)
+                for (var key : compoundValue.getAllKeys()) {
+                    if (!modifiedValue.contains(key)) {
+                        modifiedValue.put(key, compoundValue.get(key));
+                    }
+                }
+                // Return the modified value
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_LIST && value instanceof ListTag listValue) {
+
+            // <ake replacements in the individual subvalues
+            // Keep track of the modified value, which remains null while no modifications have been made
+            @Nullable ListTag modifiedValue = null;
+            for (int i = 0; i < listValue.size(); i++) {
+                var subvalue = listValue.get(i);
+                var modifiedSubvalue = replaceTag(subvalue, clientPerspectiveAndSettings, replacementScope);
+                if (modifiedSubvalue != subvalue) {
+                    // Instantiate the modified value
+                    if (modifiedValue == null) {
+                        modifiedValue = new ListTag();
+                        for (int j = 0; j < i; j++) {
+                            modifiedValue.add(listValue.get(j));
+                        }
+                    }
+                    // Set the modified subvalue in the modified value
+                    modifiedValue.add(modifiedSubvalue);
+                } else if (modifiedValue != null) {
+                    // Add the original subvalue in the modified value
+                    modifiedValue.add(subvalue);
+                }
+            }
+            // Return the modified value if it was created
+            if (modifiedValue != null) {
+                return modifiedValue;
+            }
+
+        } else if (value.getId() == Tag.TAG_STRING && value instanceof StringTag stringValue) {
+
+            // The string may be a serialized component or stringified NBT
+            var text = stringValue.getAsString();
+            var modifiedText = replaceRawJSONTextOrSNBT(text, clientPerspectiveAndSettings, replacementScope);
+            if (modifiedText != text) {
+                return StringTag.valueOf(modifiedText);
+            }
+
+        }
+
+        // By default, if no other value was returned, we return the given instance
+        return value;
+
+    }
+
+    public static @NotNull ItemStack replaceItemStack(@NotNull ItemStack value, @NotNull ItemStackInPacketContext itemStackInPacketContext, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        // TODO call implementation
+        return value;
+    }
+
+    /**
+     * Nested {@link ItemStack}s always have the {@link ItemStackInPacketContext#DEFAULT} context.
+     */
+    private static @NotNull ItemStack replaceItemStack(@NotNull ItemStack value, @NotNull ClientPerspectiveAndSettingsSupplier clientPerspectiveAndSettings, @NotNull DeepReplacementScope replacementScope) {
+        return replaceItemStack(value, ItemStackInPacketContext.DEFAULT, clientPerspectiveAndSettings, replacementScope);
+    }
+
+    private static @NotNull ComponentContents replaceTranslatableContents(@NotNull TranslatableContents value, @Nullable String locale) {
+        // TODO call implementation
+        return value;
+    }
+
+}
