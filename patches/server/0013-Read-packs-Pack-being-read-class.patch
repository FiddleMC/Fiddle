From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Sat, 6 May 2023 11:50:54 +0200
Subject: [PATCH] Read packs - Pack being read class

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/org/fiddlemc/fiddle/pack/reader/ArchivePackBeingRead.java b/src/main/java/org/fiddlemc/fiddle/pack/reader/ArchivePackBeingRead.java
new file mode 100644
index 0000000000000000000000000000000000000000..40a6f98234f280a0c51f23ff9db7a7a7816c4de3
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/reader/ArchivePackBeingRead.java
@@ -0,0 +1,60 @@
+// Fiddle - read packs
+
+package org.fiddlemc.fiddle.pack.reader;
+
+import net.sf.sevenzipjbinding.SevenZip;
+import net.sf.sevenzipjbinding.SevenZipException;
+import net.sf.sevenzipjbinding.impl.RandomAccessFileInStream;
+import net.sf.sevenzipjbinding.simple.ISimpleInArchiveItem;
+
+import java.io.*;
+import java.util.Arrays;
+
+/**
+ * A {@link PackBeingRead} that is an archive file on the disk.
+ */
+final class ArchivePackBeingRead extends PackBeingRead {
+
+    private final RandomAccessFile randomAccessFile;
+    private final ArchiveFileInPack[] files;
+
+    ArchivePackBeingRead(File packFile) throws FileNotFoundException, SevenZipException {
+        super(packFile);
+        this.randomAccessFile = new RandomAccessFile(packFile, "r");
+        var inArchive = SevenZip.openInArchive(null, new RandomAccessFileInStream(randomAccessFile));
+        this.files = Arrays.stream(inArchive.getSimpleInterface().getArchiveItems())
+            .map(item -> {
+                try {
+                    return new ArchiveFileInPack(item);
+                } catch (SevenZipException e) {
+                    throw new RuntimeException(e);
+                }
+            })
+            .toArray(ArchiveFileInPack[]::new);
+    }
+
+    @Override
+    public ArchiveFileInPack[] getFiles() {
+        return this.files;
+    }
+
+    @Override
+    void close() throws IOException {
+        this.randomAccessFile.close();
+    }
+
+    /**
+     * A file in an archive {@link PackBeingRead}.
+     */
+    class ArchiveFileInPack extends FileInPack {
+
+        private final ISimpleInArchiveItem item;
+
+        ArchiveFileInPack(ISimpleInArchiveItem item) throws SevenZipException {
+            super(item.getPath(), item.isFolder());
+            this.item = item;
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/reader/DirectoryPackBeingRead.java b/src/main/java/org/fiddlemc/fiddle/pack/reader/DirectoryPackBeingRead.java
new file mode 100644
index 0000000000000000000000000000000000000000..cecab54adf4ac300c17445a067f25297276006bf
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/reader/DirectoryPackBeingRead.java
@@ -0,0 +1,53 @@
+// Fiddle - read packs
+
+package org.fiddlemc.fiddle.pack.reader;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+/**
+ * A {@link PackBeingRead} that is a directory on the disk.
+ */
+final class DirectoryPackBeingRead extends PackBeingRead {
+
+    private final DirectoryFileInPack[] files;
+
+    DirectoryPackBeingRead(File packFile) throws IOException {
+        super(packFile);
+        try (var walk = Files.walk(packFile.toPath())) {
+            this.files = walk
+                .map(Path::toFile)
+                .map(file -> new DirectoryFileInPack(Paths.get(this.packFile.getPath()).relativize(Paths.get(file.getPath())).toString(), file))
+                .filter(file -> !file.pathInArchive.isBlank())
+                .toArray(DirectoryFileInPack[]::new);
+        }
+    }
+
+    @Override
+    public DirectoryFileInPack[] getFiles() {
+        return this.files;
+    }
+
+    @Override
+    void close() {
+        // No need to do anything
+    }
+
+    /**
+     * A file in a directory {@link PackBeingRead}.
+     */
+    class DirectoryFileInPack extends FileInPack {
+
+        private final File file;
+
+        DirectoryFileInPack(String pathInArchive, File file) {
+            super(pathInArchive, file.isDirectory());
+            this.file = file;
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/reader/PackBeingRead.java b/src/main/java/org/fiddlemc/fiddle/pack/reader/PackBeingRead.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdeb97b68aa4816523b659ae762ced7321a82d08
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/reader/PackBeingRead.java
@@ -0,0 +1,69 @@
+// Fiddle - read packs
+
+package org.fiddlemc.fiddle.pack.reader;
+
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+/**
+ * A pack that is being read.
+ * Values in this class are only set insofar reading the pack has progressed.
+ */
+public sealed abstract class PackBeingRead permits ArchivePackBeingRead, DirectoryPackBeingRead {
+
+    protected final File packFile;
+
+    /**
+     * Lazily computed: null while not initialized yet.
+     */
+    private @Nullable Map<String, FileInPack> fileByPath;
+
+    protected PackBeingRead(File packFile) {
+        this.packFile = packFile;
+    }
+
+    /**
+     * @return All files in this pack, at all levels of nesting.
+     * This does not contain an entry for the root directory of the archive.
+     */
+    public abstract FileInPack[] getFiles();
+
+    /**
+     * @return The {@linkplain FileInPack file} in this pack at the given path, or null if it doesn't exist.
+     */
+    public FileInPack getFileByPath(String path) {
+        if (this.fileByPath == null) {
+            this.fileByPath = Arrays.stream(this.getFiles())
+                .collect(Collectors.toMap(file -> file.pathInArchive, Function.identity()));
+        }
+        return this.fileByPath.get(path);
+    }
+
+    /**
+     * Closes any IO resources associated with this {@link PackBeingRead}.
+     */
+    abstract void close() throws IOException;
+
+    /**
+     * A file in a {@link PackBeingRead}.
+     */
+    @SuppressWarnings("InnerClassMayBeStatic")
+    public abstract class FileInPack {
+
+        public final String pathInArchive;
+        public final boolean isDirectory;
+
+        protected FileInPack(String pathInArchive, boolean isDirectory) {
+            this.pathInArchive = pathInArchive;
+            this.isDirectory = isDirectory;
+        }
+
+    }
+
+}
