From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Wed, 31 Jan 2024 21:58:14 +0100
Subject: [PATCH] Gameplay mechanics - Extend stonecutter recipes

Adds configuration to automatically extend stonecutter recipes. This includes:
* A setting to add the inverse of existing recipes
* A setting to add transitive recipes (i.e. if recipes A -> B and B -> C exist, A -> C will be added)

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index de4b523766e3359194656bc768cec6ea542fe117..98e71be556be6dc40cf307b1a1741ca2fea0be42 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -345,6 +345,7 @@ public class Main {
             Class.forName(net.minecraft.world.entity.npc.VillagerTrades.class.getName());// Paper - load this sync so it won't fail later async
             final DedicatedServer dedicatedserver = (DedicatedServer) MinecraftServer.spin((thread) -> {
                 DedicatedServer dedicatedserver1 = new DedicatedServer(optionset, worldLoader.get(), thread, convertable_conversionsession, resourcepackrepository, worldstem, dedicatedserversettings, DataFixers.getDataFixer(), services, LoggerChunkProgressListener::new);
+                dedicatedserver1.getRecipeManager().canAddAdditionalRecipesFromNowOn(); // Fiddle - gameplay mechanics - automatically extend stonecutter recipes
 
                 /*
                 dedicatedserver1.setPort((Integer) optionset.valueOf(optionspec10));
diff --git a/src/main/java/net/minecraft/stats/ServerRecipeBook.java b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
index 4103ddf16164e3992fef0765d368282572537e29..71856beb8430b0d70960715633cfac043ecb295f 100644
--- a/src/main/java/net/minecraft/stats/ServerRecipeBook.java
+++ b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
@@ -125,7 +125,9 @@ public class ServerRecipeBook extends RecipeBook {
                 Optional<RecipeHolder<?>> optional = recipeManager.byKey(minecraftkey);
 
                 if (optional.isEmpty()) {
+                    if (!minecraftkey.getNamespace().equals(ResourceLocation.FIDDLE_NAMESPACE)) { // Fiddle - gameplay mechanics - automatically extend stonecutter recipes - don't log player recipe book recipes that were automatically added but no longer exist
                     ServerRecipeBook.LOGGER.error("Tried to load unrecognized recipe: {} removed now.", minecraftkey);
+                    } // Fiddle - gameplay mechanics - automatically extend stonecutter recipes - don't log player recipe book recipes that were automatically added but no longer exist
                 } else {
                     handler.accept((RecipeHolder) optional.get());
                 }
diff --git a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
index b81e1802c8dcc8ebdef96d70088c18379598a66b..4f96102b3dba7c5617763bf68bfac2d3f947369f 100644
--- a/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/src/main/java/net/minecraft/world/item/crafting/RecipeManager.java
@@ -84,19 +84,607 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
             return entry1.getValue(); // CraftBukkit // Paper - decompile fix - *shrugs internally* // todo: is this needed anymore?
         }));
         this.byName = Maps.newHashMap(builder.build()); // CraftBukkit
+        this.byNameWasSet(); // Fiddle - gameplay mechanics - automatically extend stonecutter recipes
         RecipeManager.LOGGER.info("Loaded {} recipes", this.byName.size()); // Paper - log correct number of recipes
     }
 
+    // Fiddle start - gameplay mechanics - automatically extend stonecutter recipes
+    /**
+     * @return The configuration for extending stonecutter recipes,
+     * or null if this run is not a real server (for example, during unit tests).
+     */
+    private static @Nullable org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.GameplayMechanics.AddStonecutterRecipes getAddStonecutterRecipesConfiguration() {
+        var globalConfiguration = org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.get();
+        return globalConfiguration == null ? null : globalConfiguration.gameplayMechanics.addStonecutterRecipes;
+    }
+
+    private static class StonecutterRecipeWrapper {
+
+        RecipeHolder<StonecutterRecipe> recipe;
+        Pair<Integer, Integer> outputAmount;
+        boolean isViaUnaddedNonReversibleAmountInverseRecipe;
+        boolean isViaUnaddedDifferentlyShapedInverseRecipe;
+        boolean furtherInverseRecipesAreExcluded;
+        boolean furtherTransitiveRecipesAreExcluded;
+
+        StonecutterRecipeWrapper(RecipeHolder<StonecutterRecipe> recipe, Pair<Integer, Integer> outputAmount, boolean isViaUnaddedNonReversibleAmountInverseRecipe, boolean isViaUnaddedDifferentlyShapedInverseRecipe, boolean furtherInverseRecipesAreExcluded, boolean furtherTransitiveRecipesAreExcluded) {
+            this.recipe = recipe;
+            this.setOutputAmount(outputAmount);
+            this.isViaUnaddedNonReversibleAmountInverseRecipe = isViaUnaddedNonReversibleAmountInverseRecipe;
+            this.isViaUnaddedDifferentlyShapedInverseRecipe = isViaUnaddedDifferentlyShapedInverseRecipe;
+            var configuration = getAddStonecutterRecipesConfiguration();
+            this.furtherInverseRecipesAreExcluded = furtherInverseRecipesAreExcluded || anyExcludesMatch(this, configuration.excludedOrigins) || anyExcludesMatch(this, configuration.excludedOrigins) || anyExcludesMatch(RecipeManager.getOutput(recipe), RecipeManager.getInput(recipe), configuration.excludedResults) || anyExcludesMatch(RecipeManager.getOutput(recipe), RecipeManager.getInput(recipe), configuration.inverse.excludedResults);
+            this.furtherTransitiveRecipesAreExcluded = furtherTransitiveRecipesAreExcluded || anyExcludesMatch(this, configuration.excludedOrigins) || anyExcludesMatch(this, configuration.transitive.excludedOrigins);
+        }
+
+        ItemStack getInput() {
+            return RecipeManager.getInput(this.recipe);
+        }
+
+        ItemStack getOutput() {
+            return RecipeManager.getOutput(this.recipe);
+        }
+
+        boolean isIntegral() {
+            return this.outputAmount.getSecond() == 1;
+        }
+
+        boolean inputAndOutputHaveSameShape() {
+            return haveSameShape(this.getInput(), this.getOutput());
+        }
+
+        boolean canBeConsideredForTransitiveRecipes() {
+            var configuration = getAddStonecutterRecipesConfiguration();
+            return (!this.isViaUnaddedNonReversibleAmountInverseRecipe || configuration.transitive.viaUnaddedInverseRecipes.nonReversibleAmount) &&
+                (!this.isViaUnaddedDifferentlyShapedInverseRecipe || configuration.transitive.viaUnaddedInverseRecipes.differentlyShaped);
+        }
+
+        void updateRecipeOutputAmount() {
+            this.recipe.value().setOutputAmount(floorStackSize(this.outputAmount));
+        }
+
+        void setOutputAmount(Pair<Integer, Integer> outputAmount) {
+            this.outputAmount = outputAmount;
+            this.updateRecipeOutputAmount();
+        }
+
+        @Override
+        public int hashCode() {
+            return com.google.common.base.Objects.hashCode(this.recipe.id(), this.getInput().getItem(), this.getInput().getCount(), this.getOutput().getItem(), this.getOutput().getCount(), this.outputAmount.getFirst(), this.outputAmount.getSecond(), this.isViaUnaddedNonReversibleAmountInverseRecipe, this.isViaUnaddedDifferentlyShapedInverseRecipe, this.furtherInverseRecipesAreExcluded, this.furtherTransitiveRecipesAreExcluded);
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof StonecutterRecipeWrapper other && this.recipe.id().equals(other.recipe.id()) && ItemStack.isSameItemSameTags(this.getInput(), other.getInput()) && this.getInput().getCount() == other.getInput().getCount() && ItemStack.isSameItemSameTags(this.getOutput(), other.getOutput()) && this.getOutput().getCount() == other.getOutput().getCount() && this.outputAmount.getFirst() == other.outputAmount.getFirst() && this.outputAmount.getSecond() == other.outputAmount.getSecond() && this.isViaUnaddedNonReversibleAmountInverseRecipe == other.isViaUnaddedNonReversibleAmountInverseRecipe && this.isViaUnaddedDifferentlyShapedInverseRecipe == other.isViaUnaddedDifferentlyShapedInverseRecipe && this.furtherInverseRecipesAreExcluded == other.furtherInverseRecipesAreExcluded && this.furtherTransitiveRecipesAreExcluded == other.furtherTransitiveRecipesAreExcluded;
+        }
+
+        @Override
+        public String toString() {
+            return this.recipe.id() + " @ " + BuiltInRegistries.ITEM.getKey(this.getInput().getItem()) + " -> " + this.outputAmount.getFirst() + (this.outputAmount.getSecond() == 1 ? "" : " / " + this.outputAmount.getSecond()) + " " + BuiltInRegistries.ITEM.getKey(this.getOutput().getItem()) + " (" + this.isViaUnaddedNonReversibleAmountInverseRecipe + "," + this.isViaUnaddedDifferentlyShapedInverseRecipe + "," + this.furtherInverseRecipesAreExcluded + "," + this.furtherTransitiveRecipesAreExcluded + ")";
+        }
+
+        static StonecutterRecipeWrapper fromExternal(RecipeHolder<StonecutterRecipe> recipe) {
+            return new StonecutterRecipeWrapper(recipe, new Pair<>(RecipeManager.getOutputAmount(recipe), 1), false, false, false, false);
+        }
+
+    }
+
+    private @Nullable java.util.ArrayDeque<StonecutterRecipeWrapper> wrapperTodoForInverse = null;
+    private @Nullable java.util.ArrayDeque<StonecutterRecipeWrapper> wrapperTodoForTransitive = null;
+    private boolean canAddAdditionalRecipes = false;
+
+    private @Nullable Map<Integer, List<StonecutterRecipeWrapper>> recipeWrappers = null;
+    private @Nullable Map<net.minecraft.world.item.Item, List<StonecutterRecipeWrapper>> recipeWrappersByInputItem = null;
+    private @Nullable Map<net.minecraft.world.item.Item, List<StonecutterRecipeWrapper>> recipeWrappersByOutputItem = null;
+
+    private static Pair<Integer, Integer> simplifyFraction(Pair<Integer, Integer> amount) {
+        // Euclid's algorithm
+        int a = amount.getFirst();
+        int b = amount.getSecond();
+        while (b != 0) {
+            var t = b;
+            b = a % b;
+            a = t;
+        }
+        return new Pair<>(amount.getFirst() / a, amount.getSecond() / a);
+    }
+
+    private static boolean fractionIsSmaller(Pair<Integer, Integer> amount1, Pair<Integer, Integer> amount2) {
+        return amount1.getFirst() * amount2.getSecond() < amount2.getFirst() * amount1.getSecond();
+    }
+
+    private static int floorStackSize(Pair<Integer, Integer> amount) {
+        if (amount.getSecond() == 1) {
+            return Math.min(amount.getFirst(), net.minecraft.world.item.Item.MAX_STACK_SIZE);
+        }
+        for (int i = net.minecraft.world.item.Item.MAX_STACK_SIZE; i >= 2; i--) {
+            if (fractionIsSmaller(new Pair<>(i, 1), amount)) {
+                return i;
+            }
+        }
+        return 1;
+    }
+
+    private static ItemStack getInput(RecipeHolder<StonecutterRecipe> recipe) {
+        return getInput(recipe.value());
+    }
+
+    private static ItemStack getInput(StonecutterRecipe recipe) {
+        return recipe.getIngredients().get(0).getItems()[0];
+    }
+
+    private static ItemStack getOutput(RecipeHolder<StonecutterRecipe> recipe) {
+        return getOutput(recipe.value());
+    }
+
+    private static ItemStack getOutput(StonecutterRecipe recipe) {
+        return recipe.getResultItem(null);
+    }
+
+    private static int getOutputAmount(RecipeHolder<StonecutterRecipe> recipe) {
+        return getOutput(recipe).getCount();
+    }
+
+    private static boolean anyExcludesMatch(StonecutterRecipeWrapper recipe, List<org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.GameplayMechanics.AddStonecutterRecipes.Exclude> excludes) {
+        return anyExcludesMatch(recipe.recipe, excludes);
+    }
+
+    private static boolean anyExcludesMatch(RecipeHolder<StonecutterRecipe> recipe, List<org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.GameplayMechanics.AddStonecutterRecipes.Exclude> excludes) {
+        return anyExcludesMatch(getInput(recipe), getOutput(recipe), excludes);
+    }
+
+    private static boolean anyExcludesMatch(ItemStack input, ItemStack output, List<org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.GameplayMechanics.AddStonecutterRecipes.Exclude> excludes) {
+        for (var exclude : excludes) {
+            // Skip invalid excludes (without input or output)
+            if (exclude.input() == null && exclude.output() == null) {
+                continue;
+            }
+            // Skip this exclude if the input does not match
+            if (exclude.input() != null) {
+                try {
+                    if (!exclude.inputResourceLocation().equals(BuiltInRegistries.ITEM.getKey(input.getItem()))) {
+                        continue;
+                    }
+                } catch (Exception ignored) {
+                    continue;
+                }
+            }
+            // Skip this exclude if the output does not match
+            if (exclude.output() != null) {
+                try {
+                    if (!exclude.outputResourceLocation().equals(BuiltInRegistries.ITEM.getKey(output.getItem()))) {
+                        continue;
+                    }
+                } catch (Exception ignored) {
+                    continue;
+                }
+            }
+            // It matches
+            return true;
+        }
+        // No exclude matches
+        return false;
+    }
+
+    private Collection<RecipeHolder<StonecutterRecipe>> getStonecutterRecipes() {
+        return this.getAllRecipesFor(RecipeType.STONECUTTING);
+    }
+
+    private @Nullable RecipeHolder<StonecutterRecipe> findAndPotentiallyUpdateSomeExistingRecipeWithNewAmount(StonecutterRecipeWrapper wrapper) {
+        @Nullable RecipeHolder<StonecutterRecipe> bestCandidate = null;
+        var input = wrapper.getInput();
+        var output = wrapper.getOutput();
+        var newOutputAmount = output.getCount();
+        for (var candidate : this.getStonecutterRecipes()) {
+            var candidateOutput = getOutput(candidate);
+            if (!ItemStack.isSameItemSameTags(getInput(candidate), input) || !ItemStack.isSameItemSameTags(candidateOutput, output)) {
+                continue;
+            }
+            if (bestCandidate == null || candidateOutput.getCount() > getOutput(bestCandidate).getCount()) {
+                bestCandidate = candidate;
+            }
+        }
+        if (bestCandidate != null && newOutputAmount > getOutput(bestCandidate).getCount()) {
+            bestCandidate.value().setOutputAmount(newOutputAmount);
+        }
+        return bestCandidate;
+    }
+
+    private static String getUnderscoreSeparatedString(ResourceLocation resourceLocation) {
+        return resourceLocation.getNamespace() + "_" + resourceLocation.getPath();
+    }
+
+    private void byNameWasSet() {
+        if (!this.byName.isEmpty()) {
+            this.realRecipesWereAddedFromExternally(new java.util.ArrayList<>(this.byName.values()));
+        }
+    }
+
+    private static java.util.Set<it.unimi.dsi.fastutil.doubles.DoubleList> getShapeEdges(net.minecraft.world.item.BlockItem blockItem) {
+        return getShapeEdges(blockItem.getBlock());
+    }
+
+    private static java.util.Set<it.unimi.dsi.fastutil.doubles.DoubleList> getShapeEdges(net.minecraft.world.level.block.Block block) {
+        var edges = new java.util.HashSet<it.unimi.dsi.fastutil.doubles.DoubleList>();
+        block.getStateDefinition().getPossibleStates().stream().map(state ->
+            block.getCollisionShape(state, null, null, null)
+        ).forEach(shape -> shape.forAllEdges((minX, minY, minZ, maxX, maxY, maxZ) -> edges.add(it.unimi.dsi.fastutil.doubles.DoubleArrayList.of(minX, minY, minZ, maxX, maxY, maxZ))));
+        return edges;
+    }
+
+    private static boolean haveSameShape(ItemStack itemStack1, ItemStack itemStack2) {
+        return haveSameShape(itemStack1.getItem(), itemStack2.getItem());
+    }
+
+    private static List<Class<?>> alwaysSameShapeClasses = List.of(
+        net.minecraft.world.level.block.StairBlock.class,
+        net.minecraft.world.level.block.SlabBlock.class,
+        net.minecraft.world.level.block.WallBlock.class,
+        net.minecraft.world.level.block.FenceBlock.class,
+        net.minecraft.world.level.block.FenceGateBlock.class,
+        net.minecraft.world.level.block.ButtonBlock.class,
+        net.minecraft.world.level.block.PressurePlateBlock.class,
+        net.minecraft.world.level.block.WallSignBlock.class,
+        net.minecraft.world.level.block.StandingSignBlock.class,
+        net.minecraft.world.level.block.WallHangingSignBlock.class,
+        net.minecraft.world.level.block.CeilingHangingSignBlock.class,
+        net.minecraft.world.level.block.BannerBlock.class,
+        net.minecraft.world.level.block.WallBannerBlock.class,
+        net.minecraft.world.level.block.DoorBlock.class,
+        net.minecraft.world.level.block.TrapDoorBlock.class
+    );
+
+    private static boolean haveSameShape(net.minecraft.world.item.Item item1, net.minecraft.world.item.Item item2) {
+        if (item1 == item2) {
+            return true;
+        }
+        if (item1 instanceof net.minecraft.world.item.BlockItem blockItem1) {
+            if (item2 instanceof net.minecraft.world.item.BlockItem blockItem2) {
+                var block1 = blockItem1.getBlock();
+                var block2 = blockItem2.getBlock();
+                for (var alwaysSameShapeClass : alwaysSameShapeClasses) {
+                    var block1Is = alwaysSameShapeClass.isInstance(block1);
+                    var block2Is = alwaysSameShapeClass.isInstance(block2);
+                    if (block1Is || block2Is) {
+                        return block1Is && block2Is;
+                    }
+                }
+                var edges1 = getShapeEdges(blockItem1);
+                var edges2 = getShapeEdges(blockItem2);
+                return edges1.equals(edges2);
+            }
+        }
+        return false;
+    }
+
+    private static ResourceLocation createNewRecipeResourceLocation(String type, ItemStack input, ItemStack output) {
+        var inputKey = BuiltInRegistries.ITEM.getKey(input.getItem());
+        var outputKey = BuiltInRegistries.ITEM.getKey(output.getItem());
+        return new net.minecraft.resources.ResourceLocation(net.minecraft.resources.ResourceLocation.FIDDLE_NAMESPACE, type + "/" + getUnderscoreSeparatedString(inputKey) + "/" + getUnderscoreSeparatedString(outputKey));
+    }
+
+    private void realRecipesWereAddedFromExternally(List<RecipeHolder<?>> addedRecipes) {
+        this.canAddAdditionalRecipes = false;
+        for (var addedRecipe : addedRecipes) {
+            this.realRecipeWasAddedFromExternally(addedRecipe);
+        }
+        this.canAddAdditionalRecipesFromNowOn();
+    }
+
+    private void realRecipeWasAddedFromExternally(RecipeHolder<?> recipe) {
+
+        // Only do anything for stonecutter recipes
+        if (!(recipe.value() instanceof StonecutterRecipe)) {
+            return;
+        }
+
+        // Check if adding additional recipes is enabled
+        var configuration = getAddStonecutterRecipesConfiguration();
+        if (configuration == null || !(configuration.inverse.enabled || configuration.transitive.enabled)) {
+            return;
+        }
+
+        var stonecutterRecipe = (StonecutterRecipe) recipe.value();
+        ItemStack input;
+        ItemStack output;
+        try {
+            input = getInput(stonecutterRecipe);
+            output = getOutput(stonecutterRecipe);
+        } catch (Exception ignored) {
+            return;
+        }
+
+        // Skip adding additional recipes for this recipe if it is invalid in some way
+        if (input == null || output == null) {
+            return;
+        }
+        if (input.isEmpty() || output.isEmpty()) {
+            return;
+        }
+        if (input.getCount() != 1) {
+            return;
+        }
+        if (input == output || ItemStack.isSameItemSameTags(input, output)) {
+            return;
+        }
+
+        // Add all additional recipes
+        var wrapperForThisRecipe = StonecutterRecipeWrapper.fromExternal((RecipeHolder<StonecutterRecipe>) recipe);
+        if (this.recipeWrappers == null) {
+            this.recipeWrappers = new java.util.HashMap<>();
+            this.recipeWrappersByInputItem = new java.util.HashMap<>();
+            this.recipeWrappersByOutputItem = new java.util.HashMap<>();
+            for (var existingRecipe : this.getStonecutterRecipes()) {
+                var wrapperForExistingRecipe = existingRecipe == recipe ? wrapperForThisRecipe : StonecutterRecipeWrapper.fromExternal(existingRecipe);
+                this.addRecipeWrapper(wrapperForExistingRecipe);
+            }
+        } else {
+            this.addRecipeWrapper(wrapperForThisRecipe);
+        }
+        if (this.wrapperTodoForInverse == null) {
+            this.wrapperTodoForInverse = new java.util.ArrayDeque<>(1);
+            this.wrapperTodoForTransitive = new java.util.ArrayDeque<>(1);
+        }
+        this.wrapperTodoForInverse.add(wrapperForThisRecipe);
+        this.wrapperTodoForTransitive.add(wrapperForThisRecipe);
+        if (this.canAddAdditionalRecipes) {
+            this.addAdditionalRecipes();
+        }
+
+    }
+
+    public void canAddAdditionalRecipesFromNowOn() {
+        this.canAddAdditionalRecipes = true;
+        if (this.wrapperTodoForInverse != null) {
+            this.addAdditionalRecipes();
+        }
+    }
+
+    private void addAdditionalRecipes() {
+        do {
+            while (!this.wrapperTodoForInverse.isEmpty()) {
+                this.potentiallyAddInverseRecipeFor(this.wrapperTodoForInverse.poll());
+            }
+            while (!this.wrapperTodoForTransitive.isEmpty()) {
+                this.potentiallyAddTransitiveRecipesFor(this.wrapperTodoForTransitive.poll());
+            }
+        } while (!this.wrapperTodoForInverse.isEmpty());
+        this.wrapperTodoForInverse = null;
+        this.wrapperTodoForTransitive = null;
+    }
+
+    private void potentiallyAddInverseRecipeFor(StonecutterRecipeWrapper wrapper) {
+
+        // Make sure adding inverse recipes is enabled
+        var configuration = org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.get().gameplayMechanics.addStonecutterRecipes;
+        if (!configuration.inverse.enabled) {
+            return;
+        }
+        // Make sure this recipe is not excluded from checks
+        if (wrapper.furtherInverseRecipesAreExcluded) {
+            return;
+        }
+
+        // Determine the new output amount
+        var input = wrapper.getInput();
+        var output = wrapper.getOutput();
+        var newOutputAmount = wrapper.outputAmount.swap();
+        // Create the new wrapper
+        var newResourceLocation = createNewRecipeResourceLocation("inverse", output, input);
+        var newWrapper = new StonecutterRecipeWrapper(new RecipeHolder<>(newResourceLocation, new net.minecraft.world.item.crafting.StonecutterRecipe("", net.minecraft.world.item.crafting.Ingredient.of(output), input)), newOutputAmount, wrapper.isViaUnaddedNonReversibleAmountInverseRecipe, wrapper.isViaUnaddedDifferentlyShapedInverseRecipe, wrapper.furtherInverseRecipesAreExcluded, wrapper.furtherTransitiveRecipesAreExcluded);
+
+        // Really add the recipe, if appropriate
+        boolean haveSameShape = newWrapper.inputAndOutputHaveSameShape();
+        boolean isReal = false;
+        if (!configuration.inverse.onlyIfSameShape || haveSameShape) {
+            if (newWrapper.isIntegral()) {
+                // We wish to add the recipe, but first make sure we don't add duplicates
+                var updatedRecipe = this.findAndPotentiallyUpdateSomeExistingRecipeWithNewAmount(newWrapper);
+                if (updatedRecipe != null) {
+                    newWrapper.recipe = updatedRecipe;
+                } else {
+                    this.addRecipeInternal(newWrapper.recipe, false);
+                }
+                isReal = true;
+            }
+        }
+
+        // Update the wrapper based on whether it is real
+        newWrapper.isViaUnaddedNonReversibleAmountInverseRecipe |= !isReal && newOutputAmount.getSecond() == 1;
+        newWrapper.isViaUnaddedDifferentlyShapedInverseRecipe |= !isReal && !haveSameShape;
+
+        // Add the wrapper to the wrappers
+        if (this.addRecipeWrapper(newWrapper)) {
+            // Potentially add transitive recipes for the new recipe
+            this.wrapperTodoForTransitive.add(newWrapper);
+        }
+
+    }
+
+    private void potentiallyAddTransitiveRecipesFor(StonecutterRecipeWrapper wrapper) {
+
+        // Make sure adding transitive recipes is enabled
+        var configuration = org.fiddlemc.fiddle.configuration.FiddleGlobalConfiguration.get().gameplayMechanics.addStonecutterRecipes;
+        if (!configuration.transitive.enabled) {
+            return;
+        }
+        // Make sure we even need to consider this wrapper
+        if (!wrapper.canBeConsideredForTransitiveRecipes()) {
+            return;
+        }
+        // Make sure this recipe is not excluded from checks
+        if (wrapper.furtherTransitiveRecipesAreExcluded) {
+            return;
+        }
+
+        for (boolean givenWrapperIsFirst : new boolean[]{false, true}) {
+            var otherWrapperList = givenWrapperIsFirst ? this.recipeWrappersByInputItem.get(wrapper.getOutput().getItem()) : this.recipeWrappersByOutputItem.get(wrapper.getInput().getItem());
+            if (otherWrapperList != null) {
+                for (var otherWrapper : new java.util.ArrayList<>(otherWrapperList)) {
+                    // Skip if it's the same recipe
+                    if (otherWrapper == wrapper) {
+                        continue;
+                    }
+                    // Make sure we even need to consider the other wrapper
+                    if (!otherWrapper.canBeConsideredForTransitiveRecipes()) {
+                        return;
+                    }
+                    // Make sure the other recipe is not excluded from checks
+                    if (otherWrapper.furtherTransitiveRecipesAreExcluded) {
+                        return;
+                    }
+                    var firstWrapper = givenWrapperIsFirst ? wrapper : otherWrapper;
+                    var secondWrapper = givenWrapperIsFirst ? otherWrapper : wrapper;
+                    var input = firstWrapper.getInput();
+                    var output = secondWrapper.getOutput();
+                    // Make sure the resulting recipe is not excluded
+                    if (anyExcludesMatch(input, output, configuration.transitive.excludedResults) || anyExcludesMatch(input, output, configuration.excludedResults)) {
+                        return;
+                    }
+
+                    // The output of the first recipe and input of the second recipe must be the same
+                    var intermediate = firstWrapper.getOutput();
+                    if (!ItemStack.isSameItemSameTags(intermediate, secondWrapper.getInput())) {
+                        continue;
+                    }
+                    // Skip if the input and output would be the same
+                    if (ItemStack.isSameItemSameTags(input, output)) {
+                        continue;
+                    }
+
+                    // Determine the new output amount
+                    var newOutputAmount = simplifyFraction(new Pair<>(firstWrapper.outputAmount.getFirst() * secondWrapper.outputAmount.getFirst(), firstWrapper.outputAmount.getSecond() * secondWrapper.outputAmount.getSecond()));
+                    // Create the new wrapper
+                    var newResourceLocation = createNewRecipeResourceLocation("transitive", input, output);
+                    var newWrapper = new StonecutterRecipeWrapper(new RecipeHolder<>(newResourceLocation, new net.minecraft.world.item.crafting.StonecutterRecipe("", net.minecraft.world.item.crafting.Ingredient.of(input), output)), newOutputAmount, firstWrapper.isViaUnaddedNonReversibleAmountInverseRecipe || secondWrapper.isViaUnaddedNonReversibleAmountInverseRecipe, firstWrapper.isViaUnaddedDifferentlyShapedInverseRecipe || secondWrapper.isViaUnaddedDifferentlyShapedInverseRecipe, firstWrapper.furtherInverseRecipesAreExcluded || secondWrapper.furtherInverseRecipesAreExcluded, firstWrapper.furtherTransitiveRecipesAreExcluded || secondWrapper.furtherTransitiveRecipesAreExcluded);
+
+                    // Really add the recipe, if appropriate
+                    boolean mustHaveSameShape = configuration.transitive.onlyIfSameShape || (newWrapper.isViaUnaddedDifferentlyShapedInverseRecipe && configuration.inverse.onlyIfSameShape);
+                    boolean haveSameShape = newWrapper.inputAndOutputHaveSameShape();
+                    if (!mustHaveSameShape || haveSameShape) {
+                        if (newWrapper.isIntegral()) {
+                            // We wish to add the recipe, but first make sure we don't add duplicates
+                            var updatedRecipe = this.findAndPotentiallyUpdateSomeExistingRecipeWithNewAmount(newWrapper);
+                            if (updatedRecipe != null) {
+                                newWrapper.recipe = updatedRecipe;
+                            } else {
+                                this.addRecipeInternal(newWrapper.recipe, false);
+                            }
+                        }
+                    }
+
+                    // Add the wrapper to the wrappers
+                    if (this.addRecipeWrapper(newWrapper)) {
+                        // Potentially add inverse and transitive recipes for the new recipe
+                        this.wrapperTodoForInverse.add(newWrapper);
+                        this.wrapperTodoForTransitive.add(newWrapper);
+                    }
+
+                }
+            }
+        }
+    }
+    // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
+
     // CraftBukkit start
     public void addRecipe(RecipeHolder<?> irecipe) {
         org.spigotmc.AsyncCatcher.catchOp("Recipe Add"); // Spigot
+        // Fiddle start - gameplay mechanics - automatically extend stonecutter recipes
+        this.addRecipeInternal(irecipe, true);
+    }
+
+    private boolean addRecipeWrapper(StonecutterRecipeWrapper wrapper) {
+        var bucket = BuiltInRegistries.ITEM.getId(wrapper.getInput().getItem()) * BuiltInRegistries.ITEM.size() + BuiltInRegistries.ITEM.getId(wrapper.getOutput().getItem());
+        var wrapperList = this.recipeWrappers.computeIfAbsent(bucket, $ -> new java.util.ArrayList<>(1));
+        var inputItem = wrapper.getInput().getItem();
+        var outputItem = wrapper.getOutput().getItem();
+        var inputItemWrapperList = this.recipeWrappersByInputItem.computeIfAbsent(inputItem, $ -> new java.util.ArrayList<>(1));
+        var outputItemWrapperList = this.recipeWrappersByOutputItem.computeIfAbsent(outputItem, $ -> new java.util.ArrayList<>(1));
+        for (int i = 0; i < wrapperList.size(); i++) {
+            var existingWrapper = wrapperList.get(i);
+            if (ItemStack.isSameItemSameTags(existingWrapper.getInput(), wrapper.getInput()) && ItemStack.isSameItemSameTags(existingWrapper.getOutput(), wrapper.getOutput())) {
+                // Check if the new wrapper is objectively better than the existing wrapper
+                if (!wrapper.isViaUnaddedNonReversibleAmountInverseRecipe || existingWrapper.isViaUnaddedNonReversibleAmountInverseRecipe) {
+                    if (!wrapper.isViaUnaddedDifferentlyShapedInverseRecipe || existingWrapper.isViaUnaddedDifferentlyShapedInverseRecipe) {
+                        if (!wrapper.furtherInverseRecipesAreExcluded || existingWrapper.furtherInverseRecipesAreExcluded) {
+                            if (!wrapper.furtherTransitiveRecipesAreExcluded || existingWrapper.furtherTransitiveRecipesAreExcluded) {
+                                if (fractionIsSmaller(existingWrapper.outputAmount, wrapper.outputAmount)) {
+                                    // Replace the existing wrapper with the new wrapper
+                                    wrapperList.set(i, wrapper);
+                                    var indexInInputItemWrapperList = inputItemWrapperList.indexOf(existingWrapper);
+                                    inputItemWrapperList.set(indexInInputItemWrapperList, wrapper);
+                                    var indexInOutputItemWrapperList = outputItemWrapperList.indexOf(existingWrapper);
+                                    outputItemWrapperList.set(indexInOutputItemWrapperList, wrapper);
+                                    return true;
+                                }
+                            }
+                        }
+                    }
+                }
+                // Check if the existing wrapper is objectively better than or equal to the new wrapper
+                if (!existingWrapper.isViaUnaddedNonReversibleAmountInverseRecipe || wrapper.isViaUnaddedNonReversibleAmountInverseRecipe) {
+                    if (!existingWrapper.isViaUnaddedDifferentlyShapedInverseRecipe || wrapper.isViaUnaddedDifferentlyShapedInverseRecipe) {
+                        if (!existingWrapper.furtherInverseRecipesAreExcluded || wrapper.furtherInverseRecipesAreExcluded) {
+                            if (!existingWrapper.furtherTransitiveRecipesAreExcluded || wrapper.furtherTransitiveRecipesAreExcluded) {
+                                if (!fractionIsSmaller(existingWrapper.outputAmount, wrapper.outputAmount)) {
+                                    // No point in adding the new wrapper
+                                    return false;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        wrapperList.add(wrapper);
+        inputItemWrapperList.add(wrapper);
+        outputItemWrapperList.add(wrapper);
+        return true;
+    }
+
+    private void addRecipeInternal(RecipeHolder<?> irecipe, boolean isFromExternally) {
+        // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
         Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> map = this.recipes.get(irecipe.value().getType()); // CraftBukkit
 
         if (this.byName.containsKey(irecipe.id()) || map.containsKey(irecipe.id())) {
             throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.id());
         } else {
+            // Fiddle start - gameplay mechanics - automatically extend stonecutter recipes - replace automatically added recipes by external recipes
+            if (isFromExternally) {
+                if (irecipe.value() instanceof StonecutterRecipe stonecutterRecipe) {
+                    var input = getInput(stonecutterRecipe);
+                    var output = getOutput(stonecutterRecipe);
+                    var highestExistingCount = -1;
+                    for (var existingRecipe : new java.util.ArrayList<>(map.values())) {
+                        if (existingRecipe.value() instanceof StonecutterRecipe existingStonecutterRecipe) {
+                            if (!existingRecipe.id().getNamespace().equals(ResourceLocation.FIDDLE_NAMESPACE)) {
+                                continue;
+                            }
+                            var existingInput = getInput(existingStonecutterRecipe);
+                            var existingOutput = getOutput(existingStonecutterRecipe);
+                            if (!ItemStack.isSameItemSameTags(existingInput, input)) {
+                                continue;
+                            }
+                            if (!ItemStack.isSameItemSameTags(existingOutput, output)) {
+                                continue;
+                            }
+                            highestExistingCount = Math.max(highestExistingCount, existingOutput.getCount());
+                            this.removeRecipe(existingRecipe.id());
+                        }
+                    }
+                    if (highestExistingCount > output.getCount()) {
+                        stonecutterRecipe.setOutputAmount(highestExistingCount);
+                    }
+                }
+            }
+            // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes - replace automatically added recipes by external recipes
             map.putAndMoveToFirst(irecipe.id(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
             this.byName.put(irecipe.id(), irecipe);
+            // Fiddle start - gameplay mechanics - automatically extend stonecutter recipes
+            if (isFromExternally) {
+                this.realRecipeWasAddedFromExternally(irecipe);
+            }
+            // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
         }
     }
     // CraftBukkit end
@@ -214,6 +802,7 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
         });
         this.recipes = ImmutableMap.copyOf(map);
         this.byName = Maps.newHashMap(builder.build()); // CraftBukkit
+        this.byNameWasSet(); // Fiddle - gameplay mechanics - automatically extend stonecutter recipes
     }
 
     // CraftBukkit start
@@ -233,6 +822,7 @@ public class RecipeManager extends SimpleJsonResourceReloadListener {
         }
 
         this.byName = Maps.newHashMap();
+        this.byNameWasSet(); // Fiddle - gameplay mechanics - automatically extend stonecutter recipes
     }
     // CraftBukkit end
 
diff --git a/src/main/java/net/minecraft/world/item/crafting/SingleItemRecipe.java b/src/main/java/net/minecraft/world/item/crafting/SingleItemRecipe.java
index f9363f7cc74a5b7c69c7a35d1d1f741dde9214b9..fe8fccedbc775e0066084fb25978ceee8cc0c73a 100644
--- a/src/main/java/net/minecraft/world/item/crafting/SingleItemRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/SingleItemRecipe.java
@@ -11,7 +11,7 @@ import net.minecraft.world.item.ItemStack;
 
 public abstract class SingleItemRecipe implements Recipe<Container> {
     protected final Ingredient ingredient;
-    protected final ItemStack result;
+    protected ItemStack result; // Fiddle - gameplay mechanics - automatically extend stonecutter recipes - final -> non-final
     private final RecipeType<?> type;
     private final RecipeSerializer<?> serializer;
     protected final String group;
diff --git a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
index 76d1839b140e6e3ef385b54d68ed2b305d137f12..2e55d00756bfa52daeff7324d305651668e2b01f 100644
--- a/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
+++ b/src/main/java/net/minecraft/world/item/crafting/StonecutterRecipe.java
@@ -40,4 +40,11 @@ public class StonecutterRecipe extends SingleItemRecipe {
         return recipe;
     }
     // CraftBukkit end
+
+    // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
+    void setOutputAmount(int amount) {
+        this.result = this.result.copyWithCount(amount);
+    }
+    // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
+
 }
diff --git a/src/main/java/org/fiddlemc/fiddle/configuration/FiddleGlobalConfiguration.java b/src/main/java/org/fiddlemc/fiddle/configuration/FiddleGlobalConfiguration.java
index c8060a0b175447c1a83dae5a109ffd550c5343b0..a2151ec7c384342ff30ba38984a8ecc0a00e5fa6 100644
--- a/src/main/java/org/fiddlemc/fiddle/configuration/FiddleGlobalConfiguration.java
+++ b/src/main/java/org/fiddlemc/fiddle/configuration/FiddleGlobalConfiguration.java
@@ -6,8 +6,10 @@ import com.mojang.logging.LogUtils;
 import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
 import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 import java.util.HashSet;
@@ -76,4 +78,63 @@ public class FiddleGlobalConfiguration extends ConfigurationPart {
     }
     // Fiddle end - override sent feature flags
 
+    // Fiddle start - gameplay mechanics settings
+    public GameplayMechanics gameplayMechanics;
+    public class GameplayMechanics extends ConfigurationPart {
+
+        // Fiddle start - gameplay mechanics - automatically extend stonecutter recipes
+        public AddStonecutterRecipes addStonecutterRecipes;
+        public class AddStonecutterRecipes extends ConfigurationPart {
+
+            public List<Exclude> excludedOrigins = List.of();
+            public List<Exclude> excludedResults = List.of();
+
+            public Inverse inverse;
+            public class Inverse extends ConfigurationPart {
+                public boolean enabled = false;
+                public boolean onlyIfSameShape = true;
+                public List<Exclude> excludedOrigins = List.of();
+                public List<Exclude> excludedResults = List.of();
+            }
+
+            public Transitive transitive;
+            public class Transitive extends ConfigurationPart {
+
+                public boolean enabled = false;
+                public boolean onlyIfSameShape = false;
+                public List<Exclude> excludedOrigins = List.of();
+                public List<Exclude> excludedResults = List.of();
+
+                public ViaUnaddedInverseRecipes viaUnaddedInverseRecipes;
+                public class ViaUnaddedInverseRecipes extends ConfigurationPart {
+                    public boolean nonReversibleAmount = false;
+                    public boolean differentlyShaped = false;
+                }
+
+            }
+
+            @ConfigSerializable
+            public record Exclude(@Nullable String input, @Nullable String output) {
+
+                public Exclude(@Nullable String input, @Nullable String output) {
+                    this.input = input;
+                    this.output = output;
+                }
+
+                public @Nullable ResourceLocation inputResourceLocation() {
+                    return this.input == null ? null : new ResourceLocation(this.input);
+                }
+
+                public @Nullable ResourceLocation outputResourceLocation() {
+                    return this.output == null ? null : new ResourceLocation(this.output);
+                }
+
+            }
+
+        }
+        // Fiddle end - gameplay mechanics - automatically extend stonecutter recipes
+
+    }
+    // Fiddle end - gameplay mechanics settings
+
 }
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/read/SevenZipSupport.java b/src/main/java/org/fiddlemc/fiddle/pack/read/SevenZipSupport.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1a71a3c758153967b5512b76d75cfa9f48dbcfc
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/read/SevenZipSupport.java
@@ -0,0 +1,2 @@
+package org.fiddlemc.fiddle.pack.read;public class SevenZipSupport {
+}
