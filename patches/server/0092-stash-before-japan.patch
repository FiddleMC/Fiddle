From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Wed, 27 Dec 2023 13:12:20 +0100
Subject: [PATCH] stash before japan


diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 3d07c01174e85743265cddb4a6556e270511de26..973e36bff142918b6f559c7362aa23c431edcdcc 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -1,8 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Streams;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
@@ -22,9 +20,6 @@ import java.util.*;
 import java.util.function.BooleanSupplier;
 import io.papermc.paper.world.ThreadedWorldUpgrader;
 import joptsimple.OptionSet;
-import joptsimple.OptionSpec;
-import joptsimple.util.PathConverter;
-import joptsimple.util.PathProperties;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.modifier.Ownership;
 import net.bytebuddy.description.modifier.Visibility;
@@ -74,8 +69,7 @@ import net.minecraft.world.level.storage.LevelSummary;
 import net.minecraft.world.level.storage.PrimaryLevelData;
 import net.minecraft.world.level.storage.WorldData;
 import org.bukkit.Material;
-import org.fiddlemc.fiddle.packet.ClientPerspectiveCategory;
-import org.fiddlemc.fiddle.packet.item.VanillaItemOverrideVisualHandle;
+import org.fiddlemc.fiddle.packet.item.VanillaItemOverrideItemVisualHandle;
 import org.fiddlemc.fiddle.packet.locale.ServerSideTranslations;
 import org.fiddlemc.fiddle.server.FiddleFeatureSupport;
 import org.fiddlemc.fiddle.configuration.FiddleConfigurations;
@@ -96,8 +90,6 @@ import java.io.InputStreamReader;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Predicate;
 
-import net.minecraft.SharedConstants;
-
 import org.bukkit.configuration.file.YamlConfiguration;
 // CraftBukkit end
 
@@ -256,7 +248,7 @@ public class Main {
             // TODO This doesn't do anything interesting yet: should be replaced with an actual mechanism that bases this on the resource pack assets
             for (var item : BuiltInRegistries.ITEM) {
                 if (item.isAddedByFiddle()) {
-                    item.visualHandleOrProvider = new VanillaItemOverrideVisualHandle(Items.STONE, 0);
+                    item.visualHandleOrProvider = new VanillaItemOverrideItemVisualHandle(Items.STONE, 0);
                 }
             }
             // Fiddle end - client perspective - item replacements - determine and store desired visual handles
diff --git a/src/main/java/net/minecraft/world/item/Item.java b/src/main/java/net/minecraft/world/item/Item.java
index 55ad80fa233054baf4a9c40136fb1f339775745c..89f8ea3a43f7d7decd69d6b4b1aad3137ed4bef8 100644
--- a/src/main/java/net/minecraft/world/item/Item.java
+++ b/src/main/java/net/minecraft/world/item/Item.java
@@ -50,10 +50,8 @@ import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.Vec3;
-import org.fiddlemc.fiddle.packet.ClientPerspective;
-import org.fiddlemc.fiddle.packet.block.BlockStateVisualizationSetupProvider;
-import org.fiddlemc.fiddle.packet.item.VisualHandle;
-import org.fiddlemc.fiddle.packet.item.VisualHandleProvider;
+import org.fiddlemc.fiddle.packet.item.ItemVisualHandle;
+import org.fiddlemc.fiddle.packet.item.ItemVisualHandleProvider;
 import org.jetbrains.annotations.NotNull;
 import org.slf4j.Logger;
 
@@ -114,9 +112,9 @@ public class Item implements FeatureElement, ItemLike {
     /**
      * One of the following:
      * <ul>
-     *     <li>The {@link VisualHandleProvider} that provides the desired {@link VisualHandle}s
+     *     <li>The {@link ItemVisualHandleProvider} that provides the desired {@link ItemVisualHandle}s
      *     for {@link ItemStack}s of this {@linkplain Item item type}.</li>
-     *     <li>The desired {@link VisualHandle} of this item directly
+     *     <li>The desired {@link ItemVisualHandle} of this item directly
      *     (if it is the same for all {@link ItemStack}s of this item type).</li>
      *     <li>Null if all {@link ItemStack}s of this item type can be sent unmodified to all possible clients.</li>
      * </ul>
diff --git a/src/main/java/net/minecraft/world/level/block/state/BlockState.java b/src/main/java/net/minecraft/world/level/block/state/BlockState.java
index eddfcfc44416b7d9c42d3110b809e2c859bd9e93..f246f2aaebfeb3c1908185eb380a8e94908db5f5 100644
--- a/src/main/java/net/minecraft/world/level/block/state/BlockState.java
+++ b/src/main/java/net/minecraft/world/level/block/state/BlockState.java
@@ -5,10 +5,15 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.MapCodec;
 import net.minecraft.core.Registry;
 import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.state.properties.Property;
 import org.fiddlemc.fiddle.packet.ClientPerspective;
-import org.fiddlemc.fiddle.packet.block.BlockStateVisualizationSetupProvider;
+import org.fiddlemc.fiddle.packet.block.BlockStateVisualHandle;
+import org.fiddlemc.fiddle.packet.block.BlockStateVisualizationProvider;
+import org.fiddlemc.fiddle.packet.item.ItemVisualHandle;
+import org.fiddlemc.fiddle.packet.item.ItemVisualHandleProvider;
 import org.jetbrains.annotations.Nullable;
 
 public class BlockState extends BlockBehaviour.BlockStateBase {
@@ -53,13 +58,12 @@ public class BlockState extends BlockBehaviour.BlockStateBase {
     }
     // Fiddle end - cache registry indices as fields - block state
 
-    // Fiddle start - client perspective - block state visualization - BlockState field for providers
+    // Fiddle start - client perspective - block state visualization - BlockState field for visual handle
     /**
-     * The {@linkplain BlockStateVisualizationSetupProvider} that provides replacement {@link BlockState}s
-     * for this one, based on the {@linkplain ClientPerspective perspective} of a client.
-     * If null, there exist no replacements for this state, and it is always sent to clients as-is.
+     * The desired {@link BlockStateVisualHandle} of this block state,
+     * or null if all occurrences of this {@link BlockState} can be sent unmodified to all possible clients.
      */
-    public @Nullable BlockStateVisualizationSetupProvider visualizationProviders = null;
-    // Fiddle end - client perspective - block state visualization - BlockState field for providers
+    public @Nullable BlockStateVisualHandle visualHandle = null;
+    // Fiddle end - client perspective - block state visualization - BlockState field for visual handle
 
 }
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandle.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandle.java
new file mode 100644
index 0000000000000000000000000000000000000000..7faa8c9a67371924529800233c82706c27612ba5
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandle.java
@@ -0,0 +1,62 @@
+// Fiddle - client perspective - block state visualization - visual handle
+
+package org.fiddlemc.fiddle.packet.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.state.BlockState;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * A class that represents a desired model and some interaction behavior, such as collision box, selection box
+ * and potentially more, of a block state, on the client.
+ * <br>
+ * {@link BlockStateVisualHandle} instances must only be constructed during server start,
+ * and then stored in the corresponding {@link BlockState}s. The constructed {@link BlockStateVisualHandle}
+ * instances should exactly be all of (and no more than) the desired model look and block behavior combinations that
+ * could be necessary to be sent to a client.
+ */
+public interface BlockStateVisualHandle {
+
+    /**
+     * Gets the visualization method of this {@link BlockStateVisualHandle} corresponding to an occurrence of a
+     * {@link BlockState} as a state of a block in the world.
+     *
+     * @param clientPerspective The {@linkplain ClientPerspective perspective} of the target client.
+     * @return If it can be determined: a {@link Pair} of
+     * <ul>
+     *     <li>the {@link BlockState} to send instead of the original block state
+     *     that was intended to be sent, and</li>
+     *     <li>the {@link BlockStateVisualizationActionOnPacketWrite} to perform on the context of this block state,
+     *     or null if no action needs to be performed.</li>
+     * </ul>
+     * Alternatively, if determining the visualization method requires knowing the coordinates or the exact player,
+     * the return value will be null.
+     */
+    @Nullable Pair<@NotNull BlockState, @Nullable BlockStateVisualizationActionOnPacketWrite> getWorldBlockStateVisualizationMethod(@NotNull ClientPerspective clientPerspective);
+
+    /**
+     * @param level The world of the block.
+     * @param x The x coordinate of the block.
+     * @param y The x coordinate of the block.
+     * @param z The x coordinate of the block.
+     * @return The same as {@link #getWorldBlockStateVisualizationMethod(ClientPerspective)}.
+     * Alternatively, if determining the visualization method requires knowing the player,
+     * the return value will be null.
+     */
+    @Nullable Pair<@NotNull BlockState, @Nullable BlockStateVisualizationActionOnPacketWrite> getWorldBlockStateVisualizationMethod(@NotNull ClientPerspective clientPerspective, @NotNull ServerLevel level, int x, int y, int z);
+
+    /**
+     * @param player The target player to which an original block state is being sent.
+     * @return The same as
+     * {@link #getWorldBlockStateVisualizationMethod(ClientPerspective, ServerLevel, int, int, int)}.
+     * The return value can never be null.
+     */
+    @NotNull Pair<@NotNull BlockState, @Nullable BlockStateVisualizationActionOnPacketWrite> getWorldBlockStateVisualizationMethod(@NotNull ClientPerspective clientPerspective, @NotNull ServerLevel level, int x, int y, int z, @NotNull ServerPlayer player);
+
+    // TODO add methods for other visual occurrences, such as a block state appearing in a minecart entity, or in a falling block entity (which should both return an Item and custom model data)
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandleProvider.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandleProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..a079cb79612d5d565a90c4a26074b16f90ffa828
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualHandleProvider.java
@@ -0,0 +1,27 @@
+package org.fiddlemc.fiddle.packet.block;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.ItemStack;
+import org.fiddlemc.fiddle.packet.item.ItemVisualHandle;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * An abstract provider of the desired {@link BlockStateVisualHandle} of a {@link BlockState} being sent to a client,
+ * potentially based on the client's perspective and its usage context (such as the location of the block).
+ * <br>
+ * This can be used to give blocks with the same {@link Item} a different {@link ItemVisualHandle}.
+ * For example, similar to how an elytra has multiple textures (one regular texture, and one for when its durability
+ * has run out), the decision for which texture is shown in the client could be based on {@link ItemStack} properties
+ * such as durability, enchantments, or other meta contents (for example the contents of a shulker box,
+ * direction of a custom compass, degree to which a custom bow is pulled back).
+ */
+public interface BlockStateVisualHandleProvider {
+
+    /**
+     * @return The desired {@link BlockStateVisualHandle} for the given {@link ItemStack}, or null if the
+     * {@link ItemStack} can be sent unmodified to all possible clients.
+     */
+    @Nullable ItemVisualHandle getDesiredVisualHandle(@NotNull ItemStack itemStack);
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualization.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualization.java
new file mode 100644
index 0000000000000000000000000000000000000000..8792be1e03c0c86350483325caba7d25bf8895d2
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualization.java
@@ -0,0 +1,91 @@
+// Fiddle - client perspective - block state visualization - visualization definition
+
+package org.fiddlemc.fiddle.packet.block;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.state.BlockState;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * An interface that can provide both a replacement {@link BlockState}, as well as perform certain actions related to
+ * the visualization of an original {@link BlockState} that is being sent to a client.
+ * Sometimes, the visualization may require additional information
+ */
+public interface BlockStateVisualization {
+
+    /**
+     * @param original The original state of the block. Note that the original state of the block is not necessarily its
+     *                 physical state if it were retrieved from the world right now: it is the original state as being
+     *                 the state that we wish the client to be able to see as well as possible. The difference lies in
+     *                 the fact that this original state must be derived from the contents of a (potentially hypothetical)
+     *                 original packet that would be sent to the client. For example, if a plugin calls
+     *                 {@link org.bukkit.entity.Player#sendBlockChange}, this method would be called with the
+     *                 {@code actual} state being that passed to the method, not the physical state in the world.
+     *                 The original state will also already have been affected by potential anti-x-ray.
+     * @return The {@link BlockState} for this visualization, that replaces the original block state,
+     * or null if getting the block state requires
+     * {@linkplain #getBlockState(BlockState, ClientPerspective, ServerLevel, int, int, int)
+     * perspective- or location-specific information}.
+     */
+    @Nullable BlockState getBlockState(@NotNull BlockState original);
+
+    /**
+     * An alternative to {@link #getBlockState(BlockState)}
+     * that may be necessary when getting the block state requires additional player-specific information.
+     *
+     * @param level The world of the block.
+     * @param clientPerspective The {@linkplain ClientPerspective perspective} of the target client.
+     * @param x The x coordinate of the block.
+     * @param y The x coordinate of the block.
+     * @param z The x coordinate of the block.
+     * @return The {@link BlockState} for this visualization, that replaces the original block state,
+     * or null if getting the block state requires
+     * {@linkplain #getBlockState(BlockState, ClientPerspective, ServerPlayer, ServerLevel, int, int, int)
+     * player-specific information}.
+     */
+    default @Nullable BlockState getBlockState(@NotNull BlockState original, @NotNull ClientPerspective clientPerspective, @NotNull ServerLevel level, int x, int y, int z) {
+        return this.getBlockState(original);
+    }
+
+    /**
+     * An alternative to {@link #getBlockState(BlockState, ClientPerspective, ServerLevel, int, int, int)}
+     * that may be necessary when getting the block state requires additional player-specific information.
+     *
+     * @param player The player to which the target client belongs.
+     * @return The {@link BlockState} for this visualization, that replaces the original block state.
+     */
+    default @NotNull BlockState getBlockState(@NotNull BlockState original, @NotNull ClientPerspective clientPerspective, @NotNull ServerPlayer player, @NotNull ServerLevel level, int x, int y, int z) {
+        return this.getBlockState(original, clientPerspective, level, x, y, z);
+    }
+
+    /**
+     * Performs the necessary setup and registration actions for a client observing a block of which the desired
+     * visualization may change, based on dynamic circumstances.
+     * The setup must conform to the requirements set out in the documentation of
+     * {@link BlockStateVisualizationProvider#getVisualization(BlockState, ClientPerspective)}.
+     * <br>
+     * This method is called irrespective of a setup already being completed for the block in the given world
+     * and at the given coordinates: it is called any time a block update is sent to a player.
+     * In other words, if the block has remained visible to the player (i.e. not going out of view distance range),
+     * and this method has already been called a previous time, leading to some setup having been performed for
+     * the {@link BlockState} that was passed at that time, then when something leads to a block state update packet
+     * for that block being sent to the player again (normally a change in the physical state of the block), this
+     * method is called again.
+     * The implementation of this method must perform a setup that makes sure, if necessary,
+     * that an independent listener for a change in block state is registered,
+     * so that the listener can remove any active listeners associated with the old block state,
+     * that will not be relevant anymore for the new block state.
+     * The relevant setup associated with the new block state is then performed due to this method being called
+     * on the {@link BlockStateVisualization} associated with the new {@link BlockState}.
+     *
+     * @param player The player of the client that will be observing the block.
+     *
+     * @return The {@link BlockState} to show to the client initially
+     * (based on the current values of the relevant dynamic circumstances).
+     */
+    @NotNull BlockState setUp(@NotNull ServerLevel level, int x, int y, int z, @NotNull BlockState actual, @NotNull ServerPlayer player);
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationActionOnPacketWrite.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationActionOnPacketWrite.java
new file mode 100644
index 0000000000000000000000000000000000000000..3817a92c58805428f53d26ba9361e80d604e7e25
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationActionOnPacketWrite.java
@@ -0,0 +1,41 @@
+// Fiddle - client perspective - block state visualization - visualization definition
+
+package org.fiddlemc.fiddle.packet.block;
+
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * An action to be executed for a specific {@link ServerPlayer} when they would normally receive a packet containing
+ * a block state, representing the state of a block in the world.
+ * This action can generate some {@link Packet}s that are sent to the player with the original packet.
+ */
+public interface BlockStateVisualizationActionOnPacketWrite {
+
+    /**
+     * Performs the additional action that is necessary when sending a packet containing a block state that
+     * represents the state of a block in the world.
+     *
+     * @param player The target player the packet is being sent to.
+     * @param level The world of the block.
+     * @param x The x coordinate of the block.
+     * @param y The x coordinate of the block.
+     * @param z The x coordinate of the block.
+     * @return A pair of:
+     * <ul>
+     *     <li>a list of {@link Packet}s that must be sent to the client before the original packet, and</li>
+     *     <li>a list of {@link Packet}s that must be sent to the client after the original packet,</li>
+     * </ul>
+     * or null if no additional packets need to be sent.
+     */
+    @Nullable Pair<@NotNull List<@NotNull Packet<?>>, @NotNull List<@NotNull Packet<?>>> run(@NotNull ServerPlayer player, @NotNull ServerLevel level, int x, int y, int z);
+
+    @Nullable Pair<@NotNull List<@NotNull Packet<?>>, @NotNull List<@NotNull Packet<?>>> postRunAll(@NotNull ServerPlayer player, @NotNull ServerLevel level, int x, int y, int z);
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationProvider.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..2cee3d579097ffc80f4470f29c966a60a9fe97e8
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationProvider.java
@@ -0,0 +1,32 @@
+// Fiddle - client perspective - block state visualization - visualization definition
+
+package org.fiddlemc.fiddle.packet.block;
+
+import net.minecraft.world.level.block.state.BlockState;
+import org.fiddlemc.fiddle.packet.ClientPerspective;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An abstract provider for the {@linkplain BlockStateVisualization visualization} of a given {@link BlockState},
+ * given the {@linkplain ClientPerspective perspective} of the observing client.
+ */
+public interface BlockStateVisualizationProvider {
+
+    /**
+     * @return The visualization for an original {@link BlockState} that the client should receive.
+     * The return value is always one of the following two cases:
+     * <ul>
+     *     <li>A {@link BlockStateVisualization} for visualizations that are more than simply a
+     *     particular replacement {@link BlockState}. They may rely on additional dynamic
+     *     (as opposed to the static properties in {@link ClientPerspective}) circumstances,
+     *     that can perform a setup operation that subscribes to the necessary events and sends the necessary
+     *     packets to the player in response (where it must subscribe in such a way that all corresponding data in
+     *     memory is deallocated when the block becomes no longer visible to the player).</li>
+     *     <li>A {@link BlockState} that represents the look of the given {@code original} block state to the client,
+     *     that does not change based on any other dynamic circumstances.
+     *     This can be the {@code original} block state itself.</li>
+     * </ul>
+     */
+    @NotNull Object getVisualization(@NotNull BlockState original, @NotNull ClientPerspective perspective);
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetup.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetup.java
deleted file mode 100644
index ccc3d75d0464051e14bdb7f040dea3fbde5b3ce8..0000000000000000000000000000000000000000
--- a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetup.java
+++ /dev/null
@@ -1,56 +0,0 @@
-// Fiddle - client perspective - block state visualization - dynamic setup
-
-package org.fiddlemc.fiddle.packet.block;
-
-import net.minecraft.server.level.ServerLevel;
-import net.minecraft.server.level.ServerPlayer;
-import net.minecraft.world.level.block.state.BlockState;
-import org.fiddlemc.fiddle.packet.ClientPerspective;
-import org.jetbrains.annotations.NotNull;
-
-/**
- * An interface that can provide an implementation to set up the visualization of a {@link BlockState}
- * for a specific client, as is potentially returned by
- * {@link BlockStateVisualizationSetupProvider#getVisualization(BlockState, ClientPerspective)}.
- */
-public interface BlockStateVisualizationSetup {
-
-    /**
-     * Performs the necessary setup of a client observing a block of which the desired visualization
-     * may change, based on dynamic circumstances.
-     * The setup must conform to the requirements set out in the documentation of
-     * {@link BlockStateVisualizationSetupProvider#getVisualization(BlockState, ClientPerspective)}.
-     * <br>
-     * This method is called irrespective of a setup already being completed for the block in the given world
-     * and at the given coordinates: it is called any time a block update is sent to a player.
-     * In other words, if the block has remained visible to the player (i.e. not going out of view distance range),
-     * and this method has already been called a previous time, leading to some setup having been performed for
-     * the {@link BlockState} that was passed at that time, then when something leads to a block state update packet
-     * for that block being sent to the player again (normally a change in the physical state of the block), this
-     * method is called again.
-     * The implementation of this method must perform a setup that makes sure, if necessary,
-     * that an independent listener for a change in block state is registered,
-     * so that the listener can remove any active listeners associated with the old block state,
-     * that will not be relevant anymore for the new block state.
-     * The relevant setup associated with the new block state is then performed due to this method being called
-     * on the {@link BlockStateVisualizationSetup} associated with the new {@link BlockState}.
-     *
-     * @param level The world of the block.
-     * @param x The x coordinate of the block.
-     * @param y The x coordinate of the block.
-     * @param z The x coordinate of the block.
-     * @param actual The actual state of the block. Note that the actual state of the block is not necessarily its
-     *               physical state if it were retrieved from the world right now: it is the actual state as being
-     *               the state that we wish the client to be able to see as well as possible. The difference lies in
-     *               the fact that this actual state must be derived from the contents of a (potentially hypothetical)
-     *               original packet that would be sent to the client. For example, if a plugin calls
-     *               {@link org.bukkit.entity.Player#sendBlockChange}, this method would be called with the
-     *               {@code actual} state being that passed to the method, not the physical state in the world.
-     * @param player The player of the client that will be observing the block.
-     *
-     * @return The {@link BlockState} to show to the client initially
-     * (based on the current values of the relevant dynamic circumstances).
-     */
-    @NotNull BlockState setUp(@NotNull ServerLevel level, int x, int y, int z, @NotNull BlockState actual, @NotNull ServerPlayer player);
-
-}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetupProvider.java b/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetupProvider.java
deleted file mode 100644
index 712f28efd76bdcd60b299bfb07de2fe178568fa2..0000000000000000000000000000000000000000
--- a/src/main/java/org/fiddlemc/fiddle/packet/block/BlockStateVisualizationSetupProvider.java
+++ /dev/null
@@ -1,42 +0,0 @@
-// Fiddle - client perspective - block state visualization - provider
-
-package org.fiddlemc.fiddle.packet.block;
-
-import net.minecraft.world.level.block.state.BlockState;
-import org.fiddlemc.fiddle.packet.ClientPerspective;
-import org.jetbrains.annotations.NotNull;
-
-/**
- * An abstract provider for the {@link BlockStateVisualizationSetup} of a given {@link BlockState},
- * given the {@linkplain ClientPerspective perspective} of the observing client.
- */
-public interface BlockStateVisualizationSetupProvider {
-
-    /**
-     * Pre-checks whether any visualization for a given block state and perspective,
-     * that does not always return the block state itself, will exist.
-     * Implementations of this method may skip most of the checks that {@link #getVisualization} does,
-     * to quickly determine if there are no replacements necessary in a chunk or chunk section at all.
-     * @return True if there are definitely no replacements for the given perspective.
-     * False if it could not be determined for sure that there are no replacements for the given perspective
-     * (i.e. because there in fact will certainly be).
-     */
-    boolean preCheckWhetherDefinitelyHasNoVisualizationChange(@NotNull BlockState actual, @NotNull ClientPerspective perspective);
-
-    /**
-     * @return A setup for the visualization {@link BlockState} that the client should receive.
-     * The return value is always one of the following two cases:
-     * <ul>
-     *     <li>A {@link BlockStateVisualizationSetup} for visualizations that rely on dynamic
-     *     (as opposed to the static properties in {@link ClientPerspective}) circumstances,
-     *     that can perform a setup operation that subscribes to the necessary events and sends the necessary
-     *     packets to the player in response (where it must subscribe in such a way that all corresponding data in
-     *     memory is deallocated when the block becomes no longer visible to the player).</li>
-     *     <li>A {@link BlockState} that represents the look of the given {@code actual} block state to the client,
-     *     that does not change based on any other dynamic circumstances.
-     *     This can (and is probably most often) be the {@code actual} block state itself.</li>
-     * </ul>
-     */
-    @NotNull Object getVisualization(@NotNull BlockState actual, @NotNull ClientPerspective perspective);
-
-}
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationSetupProvider.java b/src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationProvider.java
similarity index 76%
rename from src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationSetupProvider.java
rename to src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationProvider.java
index 50e81d7a75117ce6c768bb238efa2878993747e9..d788d536637f0b04018ea346b20894f2ed5ae852 100644
--- a/src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationSetupProvider.java
+++ b/src/main/java/org/fiddlemc/fiddle/packet/block/OnePerCategoryBlockStateVisualizationProvider.java
@@ -13,24 +13,24 @@ import java.util.Map;
 import java.util.function.Function;
 
 /**
- * A {@link BlockStateVisualizationSetupProvider} that has one static {@link BlockState}
+ * A {@link BlockStateVisualizationProvider} that has one static {@link BlockState}
  * for each {@link ClientPerspectiveCategory}.
  */
-public final class OnePerCategoryBlockStateVisualizationSetupProvider implements BlockStateVisualizationSetupProvider {
+public final class OnePerCategoryBlockStateVisualizationProvider implements BlockStateVisualizationProvider {
 
     /**
      * The replacement {@link BlockState}s, indexed by the corresponding {@link ClientPerspectiveCategory#ordinal()}.
      */
     private final @NotNull BlockState @NotNull[] replacements;
 
-    public OnePerCategoryBlockStateVisualizationSetupProvider(@NotNull BlockState @NotNull[] replacements) {
+    public OnePerCategoryBlockStateVisualizationProvider(@NotNull BlockState @NotNull[] replacements) {
         this.replacements = replacements;
     }
 
     /**
      * Convenience constructor.
      */
-    public OnePerCategoryBlockStateVisualizationSetupProvider(@NotNull Function<@NotNull ClientPerspectiveCategory, @NotNull BlockState> replacementFunction) {
+    public OnePerCategoryBlockStateVisualizationProvider(@NotNull Function<@NotNull ClientPerspectiveCategory, @NotNull BlockState> replacementFunction) {
         this(Arrays.stream(ClientPerspectiveCategory.values()).map(replacementFunction).toArray(BlockState[]::new));
     }
 
@@ -51,7 +51,7 @@ public final class OnePerCategoryBlockStateVisualizationSetupProvider implements
 
     @Override
     public boolean equals(Object obj) {
-        return obj instanceof OnePerCategoryBlockStateVisualizationSetupProvider provider && Arrays.deepEquals(this.replacements, provider.replacements);
+        return obj instanceof OnePerCategoryBlockStateVisualizationProvider provider && Arrays.deepEquals(this.replacements, provider.replacements);
     }
 
     @Override
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/item/ItemStackInPacketReplacer.java b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemStackInPacketReplacer.java
index 991cdd399cc635fdfca7e16e7998d47429bf6a4f..7cdddbefc8cdab3cf0a1487e2a2f173a1fdc6880 100644
--- a/src/main/java/org/fiddlemc/fiddle/packet/item/ItemStackInPacketReplacer.java
+++ b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemStackInPacketReplacer.java
@@ -55,13 +55,13 @@ public final class ItemStackInPacketReplacer {
         // First, we change the type and set custom model data if necessary
         var originalItem = original.getItem();
         var visualHandleOrProvider = originalItem.visualHandleOrProvider;
-        @Nullable VisualHandle visualHandle;
+        @Nullable ItemVisualHandle visualHandle;
         if (visualHandleOrProvider == null) {
             visualHandle = null;
-        } else if (visualHandleOrProvider instanceof VisualHandle visualHandleOrProviderAsVisualHandle) {
+        } else if (visualHandleOrProvider instanceof ItemVisualHandle visualHandleOrProviderAsVisualHandle) {
             visualHandle = visualHandleOrProviderAsVisualHandle;
         } else {
-            visualHandle = ((VisualHandleProvider) visualHandleOrProvider).getDesiredVisualHandle(original);
+            visualHandle = ((ItemVisualHandleProvider) visualHandleOrProvider).getDesiredVisualHandle(original);
         }
         if (visualHandle != null) {
             var replacementItemAndCustomModelData = visualHandle.getReplacementItemAndCustomModelData(clientPerspectiveAndSettings.getPerspective(), context.typeAndCustomModelDataMapping);
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandle.java b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandle.java
similarity index 88%
rename from src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandle.java
rename to src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandle.java
index f4a4c9874ec5a331c57a5c5ee25ca42f302f8bcd..66fe063d27288c94f9ed0f83223f7a3aa77023e9 100644
--- a/src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandle.java
+++ b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandle.java
@@ -27,16 +27,16 @@ import org.jetbrains.annotations.Nullable;
  * that the server would place (for example, to allow the player to tower up while placing solid blocks,
  * or keep moving through newly placed blocks without a collision box, even under laggy conditions).
  * <br>
- * {@link VisualHandle} instances must only be constructed during server start, and then cached in a way that allows
- * the {@link VisualHandleProvider} that may provide them to return them. The constructed {@link VisualHandle}
+ * {@link ItemVisualHandle} instances must only be constructed during server start, and then cached in a way that allows
+ * the {@link ItemVisualHandleProvider} that may provide them to return them. The constructed {@link ItemVisualHandle}
  * instances should exactly be all of (and no more than) the desired item look and behavior combinations that could
  * be necessary to be sent to a client.
  */
-public interface VisualHandle {
+public interface ItemVisualHandle {
 
     /**
      * @return A pair of the {@link Item} and custom model data to set on an {@link ItemStack}, that will achieve
-     * the desired effects of this {@link VisualHandle} for the given
+     * the desired effects of this {@link ItemVisualHandle} for the given
      * {@linkplain ClientPerspective client perspective} of the target of the packet containing that {@link ItemStack}.
      * This can be null to indicate no item type or custom model data replacements need to be performed.
      */
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandleProvider.java b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandleProvider.java
similarity index 69%
rename from src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandleProvider.java
rename to src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandleProvider.java
index 62172a7b1455fef22c77c5f84c0e672be084d640..aaaf1ae9396a4ab7268a701398aaed2a607bf708 100644
--- a/src/main/java/org/fiddlemc/fiddle/packet/item/VisualHandleProvider.java
+++ b/src/main/java/org/fiddlemc/fiddle/packet/item/ItemVisualHandleProvider.java
@@ -8,20 +8,20 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 /**
- * An abstract provider of the desired {@link VisualHandle} of a given {@link ItemStack}.
+ * An abstract provider of the desired {@link ItemVisualHandle} of a given {@link ItemStack}.
  * <br>
- * This can be used to give different {@link ItemStack}s with the same {@link Item} a different {@link VisualHandle}.
+ * This can be used to give different {@link ItemStack}s with the same {@link Item} a different {@link ItemVisualHandle}.
  * For example, similar to how an elytra has multiple textures (one regular texture, and one for when its durability
  * has run out), the decision for which texture is shown in the client could be based on {@link ItemStack} properties
  * such as durability, enchantments, or other meta contents (for example the contents of a shulker box,
  * direction of a custom compass, degree to which a custom bow is pulled back).
  */
-public interface VisualHandleProvider {
+public interface ItemVisualHandleProvider {
 
     /**
-     * @return The desired {@link VisualHandle} for the given {@link ItemStack}, or null if the
+     * @return The desired {@link ItemVisualHandle} for the given {@link ItemStack}, or null if the
      * {@link ItemStack} can be sent unmodified to all possible clients.
      */
-    @Nullable VisualHandle getDesiredVisualHandle(@NotNull ItemStack itemStack);
+    @Nullable ItemVisualHandle getDesiredVisualHandle(@NotNull ItemStack itemStack);
 
 }
diff --git a/src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideVisualHandle.java b/src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideItemVisualHandle.java
similarity index 90%
rename from src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideVisualHandle.java
rename to src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideItemVisualHandle.java
index 13a7405487f2460e8ab9a04755ef32b202af8c91..d905e97dde2c38736a66931cf85d6cd54bfd0777 100644
--- a/src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideVisualHandle.java
+++ b/src/main/java/org/fiddlemc/fiddle/packet/item/VanillaItemOverrideItemVisualHandle.java
@@ -10,7 +10,7 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 /**
- * A {@link VisualHandle} with the following replacements:
+ * A {@link ItemVisualHandle} with the following replacements:
  * <ul>
  *     <li>For perspectives with the {@linkplain ClientPerspectiveCategory#JAVA_WITH_FIDDLE_CLIENT_MOD client mod},
  *     no replacement is returned.</li>
@@ -23,12 +23,12 @@ import org.jetbrains.annotations.Nullable;
  * This handle can only be sent to the client for the {@link ItemAndCustomModelDataReplacementMapping#DEFAULT} mapping.
  * For any other mapping, {@link #getReplacementItemAndCustomModelData} throws an exception.
  */
-public class VanillaItemOverrideVisualHandle implements VisualHandle {
+public class VanillaItemOverrideItemVisualHandle implements ItemVisualHandle {
 
     public final @NotNull Pair<@NotNull Item, @NotNull Integer> replacementForJavaWithEnabledResourcePackPerspective;
     public final @NotNull Pair<@NotNull Item, @NotNull Integer> fallbackReplacement;
 
-    public VanillaItemOverrideVisualHandle(@NotNull Item vanillaItem, int resourcePackTextureCustomModelData) {
+    public VanillaItemOverrideItemVisualHandle(@NotNull Item vanillaItem, int resourcePackTextureCustomModelData) {
         this.replacementForJavaWithEnabledResourcePackPerspective = Pair.of(vanillaItem, resourcePackTextureCustomModelData);
         this.fallbackReplacement = Pair.of(vanillaItem, 0);
     }
