From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Fri, 14 Jul 2023 20:18:27 +0200
Subject: [PATCH] Load packs - Read and load Fiddle blocks and items

License: Fiddle Public License Agreement 1.0 (included in license/FPL-1.0.txt)
Fiddle - https://fiddlemc.org

diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 269ed505d9375f09b3ad10550ac1790bd3929407..0a46669503131fef418a4cd200061bc4d9c50495 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -77,6 +77,7 @@ import org.fiddlemc.fiddle.server.FiddleFeatureSupport;
 import org.fiddlemc.fiddle.configuration.FiddleConfigurations;
 import org.fiddlemc.fiddle.configuration.PermanenceConfirmation;
 import org.fiddlemc.fiddle.material.*;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.fiddlemc.fiddle.pack.FiddlePacks;
@@ -219,6 +220,15 @@ public class Main {
             }
             // Fiddle end - read packs - prevent duplicate packs
 
+            // Fiddle start - load packs - blocks and items - read definitions
+            try {
+                PackFiddleDefinitionLoader.readAndPrepareDefinitions();
+            } catch (Exception e) {
+                LOGGER.error("Could not read block and item definitions", e);
+                return;
+            }
+            // Fiddle end - load packs - blocks and items - read definitions
+
             io.papermc.paper.plugin.PluginInitializerManager.load(optionset); // Paper
             Bootstrap.bootStrap();
             Bootstrap.validate();
@@ -465,6 +475,9 @@ public class Main {
                 return;
             }
 
+            // Fiddle start - load packs - blocks and items - clear read definitions
+            PackFiddleDefinitionLoader.clearCachedDefinitions();
+            // Fiddle end - load packs - blocks and items - clear read definitions
             StartupPackLoadPhase.endStartupLoadPhase(); // Fiddle - read packs - startup load phase - end after initial read
             // Fiddle start - read packs - close packs after initial read
             for (var pack : FiddlePacks.getPacks()) {
diff --git a/src/main/java/net/minecraft/world/item/Items.java b/src/main/java/net/minecraft/world/item/Items.java
index adbacee02bcd7e922fec6e406e93b2ca8aa7a31f..58145674bc0878a0c503afd9faae9f12b04cb454 100644
--- a/src/main/java/net/minecraft/world/item/Items.java
+++ b/src/main/java/net/minecraft/world/item/Items.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.item;
 
+import com.mojang.logging.LogUtils;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
 import net.minecraft.core.registries.BuiltInRegistries;
@@ -16,8 +17,14 @@ import net.minecraft.world.item.armortrim.TrimPatterns;
 import net.minecraft.world.level.block.Block;
 import net.minecraft.world.level.block.Blocks;
 import net.minecraft.world.level.material.Fluids;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
+import org.fiddlemc.fiddle.server.FiddleFeatureSupport;
+import org.slf4j.Logger;
 
 public class Items {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger(); // Fiddle end - load packs - items - register
+
     public static final Item AIR = registerBlock(Blocks.AIR, new AirItem(Blocks.AIR, new Item.Properties()));
     public static final Item STONE = registerBlock(Blocks.STONE);
     public static final Item GRANITE = registerBlock(Blocks.GRANITE);
@@ -1311,4 +1318,16 @@ public class Items {
 
         return Registry.register(BuiltInRegistries.ITEM, key, item);
     }
+
+    // Fiddle start - load packs - items - register
+    static {
+        if (FiddleFeatureSupport.supportsFiddleFeatures()) {
+            for (var definition : PackFiddleDefinitionLoader.itemDefinitions) {
+                LOGGER.info("Registering item '" + definition.untypedResourceLocation + "'");
+                definition.register();
+            }
+        }
+    }
+    // Fiddle end - load packs - items - register
+
 }
diff --git a/src/main/java/net/minecraft/world/level/block/Blocks.java b/src/main/java/net/minecraft/world/level/block/Blocks.java
index f41e335be934d24080472be9d260f1be7c01614d..36b4081a2836670c0cf6f7709c2fa85bbad33f72 100644
--- a/src/main/java/net/minecraft/world/level/block/Blocks.java
+++ b/src/main/java/net/minecraft/world/level/block/Blocks.java
@@ -1,6 +1,8 @@
 package net.minecraft.world.level.block;
 
 import java.util.function.ToIntFunction;
+
+import com.mojang.logging.LogUtils;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.core.Registry;
@@ -8,6 +10,7 @@ import net.minecraft.core.cauldron.CauldronInteraction;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.data.worldgen.features.TreeFeatures;
+import net.minecraft.resources.ResourceLocation;
 import net.minecraft.sounds.SoundEvents;
 import net.minecraft.util.valueproviders.UniformInt;
 import net.minecraft.world.effect.MobEffects;
@@ -40,8 +43,14 @@ import net.minecraft.world.level.block.state.properties.WoodType;
 import net.minecraft.world.level.material.Fluids;
 import net.minecraft.world.level.material.MapColor;
 import net.minecraft.world.level.material.PushReaction;
+import org.fiddlemc.fiddle.pack.fiddlecontent.PackFiddleDefinitionLoader;
+import org.fiddlemc.fiddle.server.FiddleFeatureSupport;
+import org.slf4j.Logger;
 
 public class Blocks {
+
+    private static final Logger LOGGER = LogUtils.getClassLogger(); // Fiddle end - load packs - blocks - register
+
     public static final Block AIR = register("air", new AirBlock(BlockBehaviour.Properties.of().replaceable().noCollission().noLootTable().air()));
     public static final Block STONE = register("stone", new Block(BlockBehaviour.Properties.of().mapColor(MapColor.STONE).instrument(NoteBlockInstrument.BASEDRUM).requiresCorrectToolForDrops().strength(1.5F, 6.0F)));
     public static final Block GRANITE = register("granite", new Block(BlockBehaviour.Properties.of().mapColor(MapColor.DIRT).instrument(NoteBlockInstrument.BASEDRUM).requiresCorrectToolForDrops().strength(1.5F, 6.0F)));
@@ -1251,11 +1260,27 @@ public class Blocks {
         return Registry.register(BuiltInRegistries.BLOCK, id, block);
     }
 
+    // Fiddle start - load packs - blocks - load definitions
+    public static Block register(ResourceLocation id, Block block) {
+        return Registry.register(BuiltInRegistries.BLOCK, id, block);
+    }
+    // Fiddle end - load packs - blocks - load definitions
+
     public static void rebuildCache() {
         Block.BLOCK_STATE_REGISTRY.forEach(BlockBehaviour.BlockStateBase::initCache);
     }
 
     static {
+
+        // Fiddle start - load packs - blocks - register
+        if (FiddleFeatureSupport.supportsFiddleFeatures()) {
+            for (var definition : PackFiddleDefinitionLoader.blockDefinitions) {
+                LOGGER.info("Registering block '" + definition.untypedResourceLocation + "'");
+                definition.register();
+            }
+        }
+        // Fiddle end - load packs - blocks - register
+
         for(Block block : BuiltInRegistries.BLOCK) {
             for(BlockState blockState : block.getStateDefinition().getPossibleStates()) {
                 Block.BLOCK_STATE_REGISTRY.add(blockState);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index dd90c85f0e1e28b4604470c356e120303efbb697..033fd651364fdf8f196736a9eea53aa85fef5f85 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -309,11 +309,11 @@ public final class CraftMagicNumbers implements UnsafeValues {
         }
         // Paper end
         for (Block block : BuiltInRegistries.BLOCK) {
-            BLOCK_MATERIAL.put(block, Material.getMaterial(block.getKeyInBlockRegistry().getPath().toUpperCase(Locale.ROOT))); // Fiddle - cache registry keys as fields - use instead of lookup - block
+            BLOCK_MATERIAL.put(block, Material.matchMaterial(block.getKeyInBlockRegistryString())); // Fiddle - cache registry keys as fields - use instead of lookup - block // Fiddle - load packs - blocks - load definitions
         }
 
         for (Item item : BuiltInRegistries.ITEM) {
-            ITEM_MATERIAL.put(item, Material.getMaterial(item.getKeyInItemRegistry().getPath().toUpperCase(Locale.ROOT))); // Fiddle - cache registry keys as fields - use instead of lookup - item
+            ITEM_MATERIAL.put(item, Material.matchMaterial(item.getKeyInItemRegistryString())); // Fiddle - cache registry keys as fields - use instead of lookup - item // Fiddle - load packs - items - load definitions
         }
 
         for (net.minecraft.world.level.material.Fluid fluidType : BuiltInRegistries.FLUID) {
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa557af62d4cd6b7e72e6a2d16a069cb1fa48afd
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleBlockDefinition.java
@@ -0,0 +1,33 @@
+// Fiddle - load packs - blocks - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An abstract definition of a block to be added to Fiddle.
+ * Implementations of this class typically represent one or more block bases.
+ */
+public abstract class AbstractFiddleBlockDefinition extends FiddleContentDefinition {
+
+    protected AbstractFiddleBlockDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(ResourceDefinitionType.BLOCK, untypedResourceLocation);
+    }
+
+    protected abstract @NotNull Block buildBlock();
+
+    /**
+     * Registers a new {@link Block} to the block registry, corresponding to this definition.
+     *
+     * @return The registered block.
+     */
+    public @NotNull Block register() {
+        var block = this.buildBlock();
+        block.setIsAddedByFiddle();
+        return Blocks.register(this.untypedResourceLocation, block);
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa060b4ec1ee0b31febdcf6bcad2c0f015ae09be
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/AbstractFiddleItemDefinition.java
@@ -0,0 +1,33 @@
+// Fiddle - load packs - items - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An abstract definition of an item to be added to Fiddle.
+ * Implementations of this class typically represent one or more item bases.
+ */
+public abstract class AbstractFiddleItemDefinition extends FiddleContentDefinition {
+
+    protected AbstractFiddleItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(ResourceDefinitionType.ITEM, untypedResourceLocation);
+    }
+
+    protected abstract @NotNull Item buildItem();
+
+    /**
+     * Registers a new {@link Item} to the item registry, corresponding to this definition.
+     *
+     * @return The registered item.
+     */
+    public @NotNull Item register() {
+        var item = this.buildItem();
+        item.setIsAddedByFiddle();
+        return Items.registerItem(this.untypedResourceLocation, item);
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..68db648075cfa50d1c1a08c477ac585511b7eaac
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockDefinition.java
@@ -0,0 +1,36 @@
+// Fiddle - load packs - blocks - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.properties.NoteBlockInstrument;
+import net.minecraft.world.level.material.MapColor;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An {@link AbstractFiddleBlockDefinition} of the most basic block base <code>minecraft:base/block</code>,
+ * corresponding to direct instances of {@link Block}.
+ */
+public class FiddleBlockDefinition extends AbstractFiddleBlockDefinition {
+
+    FiddleBlockDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    protected @NotNull BlockBehaviour.Properties buildProperties() {
+        return BlockBehaviour.Properties.of()
+            .mapColor(MapColor.STONE) // TODO make fields
+            .instrument(NoteBlockInstrument.BASEDRUM)
+            .requiresCorrectToolForDrops()
+            .strength(1.5F, 6.0F);
+    }
+
+    @Override
+    protected @NotNull Block buildBlock() {
+        return new Block(this.buildProperties());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f8fecc03c01660676d6905fe30ebcd5ec01ec95
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleBlockItemDefinition.java
@@ -0,0 +1,47 @@
+// Fiddle - load packs - items - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * An {@link AbstractFiddleItemDefinition} of the item base <code>minecraft:base/item/block</code>,
+ * corresponding to direct instances of {@link BlockItem}.
+ */
+public class FiddleBlockItemDefinition extends FiddleItemDefinition {
+
+    FiddleBlockItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    @Override
+    public @NotNull List<@NotNull ResourceLocation> getReferencedResourceLocation(@NotNull ResourceDefinitionType type) {
+        var references = super.getReferencedResourceLocation(type);
+        if (type == ResourceDefinitionType.BLOCK) {
+            references = references instanceof ArrayList<?> ? references : new ArrayList<>(references);
+            references.add(this.untypedResourceLocation);
+        }
+        return references;
+    }
+
+    @Override
+    protected @NotNull BlockItem buildItem() {
+        return new BlockItem(BuiltInRegistries.BLOCK.get(this.untypedResourceLocation), this.buildProperties());
+    }
+
+    @Override
+    public @NotNull Item register() {
+        var item = this.buildItem();
+        item.setIsAddedByFiddle();
+        return Items.registerBlock(item);
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..952550f83f71f9fdf00c100da8ea23dc39697b4c
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleContentDefinition.java
@@ -0,0 +1,109 @@
+// Fiddle - load packs - blocks and items - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.level.block.Block;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+import java.util.stream.IntStream;
+
+/**
+ * A common base class for {@link FiddleBlockDefinition} and {@link FiddleItemDefinition}.
+ */
+public abstract class FiddleContentDefinition {
+
+    public final @NotNull ResourceDefinitionType type;
+
+    /**
+     * The untyped {@link ResourceLocation}, for example <code>minecraft:stone_bricks</code>.
+     */
+    public final @NotNull ResourceLocation untypedResourceLocation;
+
+    protected FiddleContentDefinition(@NotNull ResourceDefinitionType type, @NotNull ResourceLocation untypedResourceLocation) {
+        this.type = type;
+        this.untypedResourceLocation = untypedResourceLocation;
+    }
+
+    /**
+     * @return The typed {@link ResourceLocation}, for example <code>minecraft:block/stone_bricks</code>.
+     */
+    public final @NotNull ResourceLocation getTypedResourceLocation() {
+        return new ResourceLocation(this.untypedResourceLocation.getNamespace(), this.type.resourceLocationPathIdentifier + "/" + this.untypedResourceLocation.getPath());
+    }
+
+    /**
+     * @return A list of the untyped references in this definition,
+     * that require the referenced content to have been instantiated.
+     * For example, a {@link FiddleBlockItemDefinition} relies on its corresponding {@link FiddleBlockDefinition}
+     * to have been instantiated as a {@link Block} before being able to be instantiated as a {@link BlockItem}.
+     */
+    public @NotNull List<@NotNull ResourceLocation> getReferencedResourceLocation(@NotNull ResourceDefinitionType type) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public @NotNull String toString() {
+        return this.untypedResourceLocation.toString();
+    }
+
+    /**
+     * Gets a topologically sorted copy of the given {@code definitions}.
+     * <br>
+     * All definitions in the given list must have the same {@linkplain #type type}
+     * (this is not checked by the implementation of this method).
+     * There may not be duplicate elements in the given list
+     * (this is not checked by the implementation of this method).
+     *
+     * @return A new list, containing the same elements as the given list,
+     * but ordered topologically according to the dependency forest defined by the
+     * {@linkplain #getReferencedResourceLocation(ResourceDefinitionType) references} that definitions have to
+     * other definitions in the list.
+     *
+     * @throws IllegalArgumentException If there is a cyclic dependency in the given definitions.
+     */
+    public static <T extends FiddleContentDefinition> @NotNull List<@NotNull T> getSortedTopologicallyByReferences(@NotNull List<@NotNull T> definitions) {
+        if (definitions.isEmpty()) {
+            return Collections.emptyList();
+        }
+        Map<T, Integer> toIndexInDefinitions = new IdentityHashMap<>();
+        for (int i = 0; i < definitions.size(); i++) {
+            toIndexInDefinitions.put(definitions.get(i), i);
+        }
+        int[] dependenciesLeftToAdd = new int[definitions.size()];
+        List<List<T>> dependents = new ArrayList<>();
+        for (int i = 0; i < definitions.size(); i++) {
+            dependents.add(new ArrayList<>());
+        }
+        for (var definition : definitions) {
+            for (var dependency : definition.getReferencedResourceLocation(definition.type)) {
+                dependents.get(toIndexInDefinitions.get(dependency)).add(definition);
+            }
+        }
+        Queue<T> noUnaddedDependencies = new ArrayDeque<>(definitions.size());
+        for (int i = 0; i < definitions.size(); i++) {
+            if (dependenciesLeftToAdd[i] == 0) {
+                noUnaddedDependencies.add(definitions.get(i));
+            }
+        }
+        List<T> sorted = new ArrayList<>(definitions.size());
+        while (!noUnaddedDependencies.isEmpty()) {
+            var toAdd = noUnaddedDependencies.poll();
+            sorted.add(toAdd);
+            for (var dependent : dependents.get(toIndexInDefinitions.get(toAdd))) {
+                if (--dependenciesLeftToAdd[toIndexInDefinitions.get(dependent)] == 0) {
+                    noUnaddedDependencies.add(dependent);
+                }
+            }
+        }
+        if (sorted.size() == definitions.size()) {
+            return sorted;
+        }
+        // There was a cycle
+        // TODO backtrack to find it and report back the actual cycle
+        throw new IllegalArgumentException("There was a cyclic dependency in definitions of type '" + definitions.get(0).type.resourceLocationPathIdentifier + "'. The cycle is made up of some (but not all) of the following definitions: " + IntStream.range(0, definitions.size()).filter(index -> dependenciesLeftToAdd[index] > 0).mapToObj(definitions::get).map(definition -> definition.untypedResourceLocation.toString()).toList());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0510796fae7ad6b1c7f9231f97ad7c6dc09023b
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/FiddleItemDefinition.java
@@ -0,0 +1,33 @@
+// Fiddle - load packs - items - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.properties.NoteBlockInstrument;
+import net.minecraft.world.level.material.MapColor;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An {@link AbstractFiddleItemDefinition} of the most basic item base <code>minecraft:base/item</code>,
+ * corresponding to direct instances of {@link Item}.
+ */
+public class FiddleItemDefinition extends AbstractFiddleItemDefinition {
+
+    FiddleItemDefinition(@NotNull ResourceLocation untypedResourceLocation) {
+        super(untypedResourceLocation);
+    }
+
+    protected @NotNull Item.Properties buildProperties() {
+        return new Item.Properties(); // TODO make properties fields
+    }
+
+    @Override
+    protected @NotNull Item buildItem() {
+        return new Item(this.buildProperties());
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..6f886c203eaf2408260b6acd6795e4d6c1d18084
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionLoader.java
@@ -0,0 +1,91 @@
+// Fiddle - load packs - blocks and items - load definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.resources.ResourceLocation;
+import org.fiddlemc.fiddle.pack.FiddlePack;
+import org.fiddlemc.fiddle.pack.FiddlePacks;
+import org.fiddlemc.fiddle.pack.read.PackParseException;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Callable;
+
+/**
+ * A utility class providing functionality to take {@linkplain PackFiddleDefinitionReader already read}
+ * definitions, prepare them to be loaded into the server and actually load them at the right moment.
+ */
+public final class PackFiddleDefinitionLoader {
+
+    private PackFiddleDefinitionLoader() {
+        throw new RuntimeException();
+    }
+
+    private static final @NotNull Logger LOGGER = LogUtils.getClassLogger();
+
+    /**
+     * Will be null until initialized, and null after processing has finished (to deallocate the memory).
+     */
+    public static @Nullable List<AbstractFiddleBlockDefinition> blockDefinitions;
+
+    /**
+     * Will be null until initialized, and null after processing has finished (to deallocate the memory).
+     */
+    public static @Nullable List<AbstractFiddleItemDefinition> itemDefinitions;
+
+    private static <T extends FiddleContentDefinition> void readDefinitionsAndAddToMap(Map<ResourceLocation, Pair<T, FiddlePack>> map, ResourceDefinitionType type, FiddlePack pack, Callable<List<T>> readDefinitions) throws PackParseException {
+        try {
+            for (var definition : readDefinitions.call()) {
+                var existingEntry = map.get(definition.untypedResourceLocation);
+                if (existingEntry != null) {
+                    throw new PackParseException("Two packs both declare the same " + type.resourceLocationPathIdentifier + ": pack '" + existingEntry.second() + "' and pack '" + pack + "' both declare the " + type.resourceLocationPathIdentifier + " '" + definition.untypedResourceLocation + "'");
+                }
+                map.put(definition.untypedResourceLocation, Pair.of(definition, pack));
+            }
+        } catch (Exception e) {
+            throw new PackParseException("Could not read " + type.contentSubNamespaceFolderName + " from a Fiddle pack '" + pack + "'", e);
+        }
+    }
+
+    /**
+     * Reads the definitions from packs and performs any needed preparations
+     * (notably, storing them in memory so they can be used in the corresponding loading actions later).
+     */
+    public static void readAndPrepareDefinitions() throws PackParseException {
+        // Create a map from each unique resource location to its corresponding resource and the pack that declared it
+        var untypedResourceLocationToBlockDefinitionAndDeclaringPack = new HashMap<ResourceLocation, Pair<AbstractFiddleBlockDefinition, FiddlePack>>();
+        var untypedResourceLocationToItemDefinitionAndDeclaringPack = new HashMap<ResourceLocation, Pair<AbstractFiddleItemDefinition, FiddlePack>>();
+        // Read the definitions from each pack
+        for (var pack : FiddlePacks.getPacks()) {
+            // Read the block definitions
+            readDefinitionsAndAddToMap(
+                untypedResourceLocationToBlockDefinitionAndDeclaringPack,
+                ResourceDefinitionType.BLOCK,
+                pack,
+                () -> PackFiddleDefinitionReader.readBlocks(pack)
+            );
+            // Read the item definitions
+            readDefinitionsAndAddToMap(
+                untypedResourceLocationToItemDefinitionAndDeclaringPack,
+                ResourceDefinitionType.ITEM,
+                pack,
+                () -> PackFiddleDefinitionReader.readItems(pack)
+            );
+        }
+        // Store the definitions, topologically ordered by cross-references
+        blockDefinitions = FiddleContentDefinition.getSortedTopologicallyByReferences(untypedResourceLocationToBlockDefinitionAndDeclaringPack.values().stream().map(Pair::left).toList());
+        itemDefinitions = FiddleContentDefinition.getSortedTopologicallyByReferences(untypedResourceLocationToItemDefinitionAndDeclaringPack.values().stream().map(Pair::left).toList());
+    }
+
+    public static void clearCachedDefinitions() {
+        blockDefinitions = null;
+        itemDefinitions = null;
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..f492be1f5d4bb595ecb7e6dc269974f6c65c40df
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/PackFiddleDefinitionReader.java
@@ -0,0 +1,146 @@
+// Fiddle - load packs - blocks and items - read definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
+import com.mojang.logging.LogUtils;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.resources.ResourceLocation;
+import org.fiddlemc.fiddle.pack.FiddlePack;
+import org.fiddlemc.fiddle.pack.files.RegularFileInPack;
+import org.fiddlemc.fiddle.pack.read.ContentNamespacedKeyValidation;
+import org.fiddlemc.fiddle.pack.read.PackParseException;
+import org.fiddlemc.fiddle.pack.read.json.NamedJsonElement;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/**
+ * A utility class providing functionality to read definitions of blocks and items from a {@link FiddlePack}.
+ */
+public final class PackFiddleDefinitionReader {
+
+    private PackFiddleDefinitionReader() {
+        throw new RuntimeException();
+    }
+
+    private static final @NotNull String contentFolderName = "content";
+
+    private static final @NotNull Logger LOGGER = LogUtils.getClassLogger();
+
+    /**
+     * @return A (possibly empty) list of all regular files in the {@linkplain #contentFolderName Fiddle folder in packs},
+     * that have the following path:
+     * <code>&lt;pack root&gt;/&lt;{@link #contentFolderName}&gt;/&lt;a {@link ContentNamespacedKeyValidation#isValidNamespace valid namespace}&gt;/&lt;{@code subNamespaceFolderName}&gt;/&lt;a {@linkplain ContentNamespacedKeyValidation#isValidPathJSONFilename(String) valid namespaced key path}&gt;</the></the></the></code>,
+     * paired with their namespace.
+     */
+    private static @NotNull List<@NotNull Pair<@NotNull RegularFileInPack, @NotNull String>> getSubNamespacedFolderFilesInContentFolder(@NotNull FiddlePack pack, @NotNull String subNamespaceFolderName) throws PackParseException {
+        var contentFolder = pack.filesProvider().getTopLevelDirectory(contentFolderName);
+        if (contentFolder == null) {
+            return Collections.emptyList();
+        }
+        List<Pair<RegularFileInPack, String>> subNamespacedFolderFiles = new ArrayList<>(0);
+        for (var namespaceFolder : contentFolder.getTopLevelDirectories()) {
+            var namespace = namespaceFolder.getName();
+            if (!ContentNamespacedKeyValidation.isValidNamespace(namespace)) {
+                LOGGER.warn("Ignored invalid namespace folder in Fiddle pack: {} in {}", contentFolderName + "/" + namespace, pack.filesProvider().getLocation());
+                continue;
+            }
+            var subNamespaceFolder = namespaceFolder.getTopLevelDirectory(subNamespaceFolderName);
+            if (subNamespaceFolder == null) {
+                continue;
+            }
+            for (var subNamespaceFolderFile : subNamespaceFolder.getTopLevelRegularFiles()) {
+                var path = subNamespaceFolderFile.getName();
+                if (!ContentNamespacedKeyValidation.isValidPathJSONFilename(path)) {
+                    LOGGER.warn("Ignored invalid file name in Fiddle pack: {} in {}", contentFolderName + "/" + namespace + "/" + subNamespaceFolderName + "/" + path, pack.filesProvider().getLocation());
+                    continue;
+                }
+                subNamespacedFolderFiles.add(Pair.of(subNamespaceFolderFile, namespace));
+            }
+        }
+        return subNamespacedFolderFiles;
+    }
+
+    /**
+     * @return The same as {@link #getSubNamespacedFolderFilesInContentFolder}, but each pair of a file and
+     * namespace has been turned into the file opened and parsed as JSON, and the {@link ResourceLocation} made
+     * of the namespace and path.
+     */
+    private static @NotNull List<@NotNull Pair<@NotNull JsonElement, @NotNull ResourceLocation>> getSubNamespacedFolderFilesInContentFolderAsJSON(@NotNull FiddlePack pack, @NotNull String subNamespaceFolderName) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolder(pack, subNamespaceFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<Pair<JsonElement, ResourceLocation>> subNamespacedFolderFilesInContentFolderAsJSON = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var file = namespacedFolderFile.first();
+            var namespace = namespacedFolderFile.second();
+            var filename = file.getName();
+            var path = filename.substring(0, filename.length() - 5); // Remove .json
+            var resourceLocation = new ResourceLocation(namespace, path);
+            String fullFilePathInPack = contentFolderName + "/" + namespace + "/" + subNamespaceFolderName + "/" + path;
+            String fileContent;
+            try {
+                fileContent = file.getString(false);
+            } catch (Exception e) {
+                throw new PackParseException("An exception occurred while opening a file '" + fullFilePathInPack + "' in a pack '" + pack + "'.", e);
+            }
+            JsonElement json;
+            try {
+                json = JsonParser.parseString(fileContent);
+            } catch (Exception e) {
+                throw new PackParseException("An exception occurred while parsing '" + fullFilePathInPack + "' in a pack '" + pack + "' as JSON.", e);
+            }
+            subNamespacedFolderFilesInContentFolderAsJSON.add(Pair.of(json, resourceLocation));
+        }
+        return subNamespacedFolderFilesInContentFolderAsJSON;
+    }
+
+    public static @NotNull List<@NotNull AbstractFiddleBlockDefinition> readBlocks(@NotNull FiddlePack pack) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolderAsJSON(pack, ResourceDefinitionType.BLOCK.contentSubNamespaceFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<AbstractFiddleBlockDefinition> blocks = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var json = namespacedFolderFile.first();
+            var resourceLocation = namespacedFolderFile.second();
+            try {
+                var blockJson = NamedJsonElement.get(json).getAsJsonObject();
+                // TODO read the parent
+                blocks.add(new FiddleBlockDefinition(resourceLocation));
+                // TODO read the collision box per block state (and provide a way to make it the same as the shape of that block state in assets/.../blockstates - although
+                // TODO same as above but the hit box
+            } catch (Exception e) {
+                throw new PackParseException("Could not parse block definition '" + resourceLocation + "' in pack '" + pack + "'", e);
+            }
+        }
+        return blocks;
+    }
+
+    public static @NotNull List<@NotNull AbstractFiddleItemDefinition> readItems(@NotNull FiddlePack pack) throws PackParseException {
+        var namespacedFolderFiles = getSubNamespacedFolderFilesInContentFolderAsJSON(pack, ResourceDefinitionType.ITEM.contentSubNamespaceFolderName);
+        if (namespacedFolderFiles.isEmpty()) {
+            return Collections.emptyList();
+        }
+        List<AbstractFiddleItemDefinition> items = new ArrayList<>(namespacedFolderFiles.size());
+        for (var namespacedFolderFile : namespacedFolderFiles) {
+            var json = namespacedFolderFile.first();
+            var resourceLocation = namespacedFolderFile.second();
+            try {
+                var itemJson = NamedJsonElement.get(json).getAsJsonObject();
+                // TODO read the parent
+                items.add(new FiddleBlockItemDefinition(resourceLocation));
+            } catch (Exception e) {
+                throw new PackParseException("Could not parse item definition '" + resourceLocation + "' in pack '" + pack + "'", e);
+            }
+        }
+        return items;
+    }
+
+}
diff --git a/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..5f89159c38b57b7b8d03d0c3e285c936930fa167
--- /dev/null
+++ b/src/main/java/org/fiddlemc/fiddle/pack/fiddlecontent/ResourceDefinitionType.java
@@ -0,0 +1,50 @@
+// Fiddle - load packs - blocks and items - definitions
+
+package org.fiddlemc.fiddle.pack.fiddlecontent;
+
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/**
+ * The type of content of a {@link ResourceDefinitionType}.
+ * This enum may also include content definition types that are not part of Fiddle,
+ * such as block models, crafting recipes or advancements.
+ */
+public enum ResourceDefinitionType {
+
+    /**
+     * The type of {@link FiddleBlockDefinition}s.
+     */
+    BLOCK("blocks", "block"),
+    /**
+     * The type of {@link FiddleItemDefinition}s.
+     */
+    ITEM("items", "item");
+
+    /**
+     * The name of the folder corresponding to this type of resource,
+     * when it is in a namespace folder inside the <code>content</code> folder in a Fiddle pack.
+     * This is null if this type of resource is not in the <code>content</code> folder.
+     * <br>
+     * For example, for {@link #BLOCK} this is <code>blocks</code>, as block definitions are read from the
+     * <code>&lt;pack root&gt;/content/&lt;namespace&gt;/blocks</code> folder.
+     */
+    public final @Nullable String contentSubNamespaceFolderName;
+
+    /**
+     * The identifier in a typed {@link ResourceLocation} path, that is used as a prefix together with the
+     * <code>/</code> character.
+     * <br>
+     * For example, for {@link #BLOCK} this is <code>block</code>, as a block with the untyped {@link ResourceLocation}
+     * <code>masonry:tuff_bricks</code> would have the typed {@link ResourceLocation}
+     * <code>masonry:block/tuff_bricks</code>.
+     */
+    public final @NotNull String resourceLocationPathIdentifier;
+
+    ResourceDefinitionType(@Nullable String contentSubNamespaceFolderName, @NotNull String resourceLocationPathIdentifier) {
+        this.contentSubNamespaceFolderName = contentSubNamespaceFolderName;
+        this.resourceLocationPathIdentifier = resourceLocationPathIdentifier;
+    }
+
+}
